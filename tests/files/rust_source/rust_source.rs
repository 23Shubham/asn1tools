//! This file was generated by asn1tools version 0.145.3 Mon Jan 28 18:59:39 2019.

#[derive(Debug, PartialEq, Copy, Clone)]
pub enum Error {
    BadChoice,
    BadEnum,
    BadLength,
    OutOfData,
    OutOfMemory
}

pub struct Encoder<'a> {
    buf: &'a mut [u8],
    size: usize,
    pos: usize,
    error: Option<Error>
}

pub struct Decoder<'a> {
    buf: &'a[u8],
    size: usize,
    pos: usize,
    error: Option<Error>
}

impl<'a> Encoder<'a> {
    fn new(dst: &'a mut [u8]) -> Encoder {
        Encoder {
            size: 8 * dst.len(),
            buf: dst,
            pos: 0,
            error: None
        }
    }

    fn get_result(&self) -> Result<usize, Error> {
        if self.error.is_none() {
            return Ok((self.pos + 7) / 8);
        } else {
            return Err(self.error.unwrap());
        }
    }

    fn abort(&mut self, error: Error) {
        if self.error.is_none() {
            self.error = Some(error);
        }
    }

    fn alloc(&mut self, size: usize) -> Result<usize, ()> {
        if self.pos + size <= self.size {
            let pos = self.pos;
            self.pos += size;
            Ok(pos)
        } else {
            self.abort(Error::OutOfMemory);
            Err(())
        }
    }

    fn append_bit(&mut self, value: u8) {
        if let Ok(pos) = self.alloc(1) {
            if pos % 8 == 0 {
                self.buf[pos / 8] = 0;
            }

            self.buf[pos / 8] |= value << (7 - (pos % 8));
        }
    }

    fn append_bytes(&mut self, buf: &[u8]) {
        if let Ok(pos) = self.alloc(8 * buf.len()) {
            let byte_pos = pos / 8;
            let pos_in_byte = pos % 8;

            if pos_in_byte == 0 {
                self.buf.get_mut(byte_pos..byte_pos + buf.len())
                    .unwrap()
                    .copy_from_slice(buf.get(0..buf.len()).unwrap());
            } else {
                for i in 0..buf.len() {
                    self.buf[byte_pos + i] |= buf[i] >> pos_in_byte;
                    self.buf[byte_pos + i + 1] = buf[i] << (8 - pos_in_byte);
                }
            }
        }
    }

    fn append_u8(&mut self, value: u8) {
        self.append_bytes(&value.to_be_bytes());
    }

    fn append_u16(&mut self, value: u16) {
        self.append_bytes(&value.to_be_bytes());
    }

    fn append_u32(&mut self, value: u32) {
        self.append_bytes(&value.to_be_bytes());
    }

    fn append_u64(&mut self, value: u64) {
        self.append_bytes(&value.to_be_bytes());
    }

    fn append_i8(&mut self, value: i8) {
        self.append_u8((value as u8).wrapping_add(128));
    }

    fn append_i16(&mut self, value: i16) {
        self.append_u16((value as u16).wrapping_add(32768));
    }

    fn append_i32(&mut self, value: i32) {
        self.append_u32((value as u32).wrapping_add(2147483648));
    }

    fn append_i64(&mut self, value: i64) {
        self.append_u64((value as u64).wrapping_add(9223372036854775808));
    }

    fn append_bool(&mut self, value: bool) {
        self.append_bit(value as u8);
    }

    fn append_non_negative_binary_integer(&mut self, value: u64, size: usize) {
        for i in 0..size {
            self.append_bit((value >> (size - i - 1)) as u8 & 1);
        }
    }
}

impl<'a> Decoder<'a> {
    fn new(src: &'a[u8]) -> Decoder {
        Decoder {
            buf: src,
            size: 8 * src.len(),
            pos: 0,
            error: None
        }
    }

    fn get_result(&self) -> Result<usize, Error> {
        if self.error.is_none() {
            Ok((self.pos + 7) / 8)
        } else {
            Err(self.error.unwrap())
        }
    }

    fn abort(&mut self, error: Error) {
        if self.error.is_none() {
            self.error = Some(error);
        }
    }

    fn free(&mut self, size: usize) -> Result<usize, ()> {
        if self.pos + size <= self.size {
            let pos = self.pos;
            self.pos += size;
            Ok(pos)
        } else {
            self.abort(Error::OutOfData);
            Err(())
        }
    }

    fn read_bit(&mut self) -> u8 {
        if let Ok(pos) = self.free(1) {
            (self.buf[pos / 8] >> (7 - (pos % 8))) & 1
        } else {
            0
        }
    }

    fn read_bytes(&mut self, buf: &mut [u8]) {
        if let Ok(pos) = self.free(8 * buf.len()) {
            let byte_pos = pos / 8;
            let pos_in_byte = pos % 8;

            if pos_in_byte == 0 {
                buf.copy_from_slice(
                    self.buf.get(byte_pos..byte_pos + buf.len()).unwrap());
            } else {
                for i in 0..buf.len() {
                    buf[i] = self.buf[byte_pos + i] << pos_in_byte;
                    buf[i] |= self.buf[byte_pos + i + 1] >> (8 - pos_in_byte);
                }
            }
        }
    }

    fn read_u8(&mut self) -> u8 {
        let mut buf = [0; 1];

        self.read_bytes(&mut buf);

        u8::from_be_bytes(buf)
    }

    fn read_u16(&mut self) -> u16 {
        let mut buf = [0; 2];

        self.read_bytes(&mut buf);

        u16::from_be_bytes(buf)
    }

    fn read_u32(&mut self) -> u32 {
        let mut buf = [0; 4];

        self.read_bytes(&mut buf);

        u32::from_be_bytes(buf)
    }

    fn read_u64(&mut self) -> u64 {
        let mut buf = [0; 8];

        self.read_bytes(&mut buf);

        u64::from_be_bytes(buf)
    }

    fn read_i8(&mut self) -> i8 {
        self.read_u8().wrapping_sub(128) as i8
    }

    fn read_i16(&mut self) -> i16 {
        self.read_u16().wrapping_sub(32768) as i16
    }

    fn read_i32(&mut self) -> i32 {
        self.read_u32().wrapping_sub(2147483648) as i32
    }

    fn read_i64(&mut self) -> i64 {
        self.read_u64().wrapping_sub(9223372036854775808) as i64
    }

    fn read_bool(&mut self) -> bool {
        self.read_bit() != 0
    }

    fn read_non_negative_binary_integer(&mut self, size: usize) -> u64 {
        let mut value: u64 = 0;

        for _ in 0..size {
            value <<= 1;
            value |= self.read_bit() as u64;
        }

        value
    }
}


// Type A in module RustSource.
struct RustSourceA {
    a: i8;
    b: i16;
    c: i32;
    d: i64;
    e: u8;
    f: u16;
    g: u32;
    h: u64;
    i: bool;
    struct {
        uint8_t buf[11];
    j: };
};

// Type AB in module RustSource.
struct RustSourceAB {
    a: i8;
    b: u16;
};

// Type D in module RustSource.
enum a_rust_source_d_a_b_choice_e {
    a_rust_source_d_a_b_choice_c_e,
    a_rust_source_d_a_b_choice_d_e
};

enum a_rust_source_d_g_h_e {
    a_rust_source_d_g_h_i_e,
    a_rust_source_d_g_h_j_e,
    a_rust_source_d_g_h_k_e
};

struct RustSourceD {
    let length: u8;
    struct {
        struct {
            struct {
                enum a_rust_source_d_a_b_choice_e choice;
                union {
                    u8 c;
                    bool d;
                } value;
            b: };
            struct {
                let length: u8;
            e: };
        a: };
        struct {
            h: enum a_rust_source_d_g_h_e;
            struct {
                let length: u8;
                uint8_t buf[2];
            l: };
        g: };
        struct {
            is_n_present: bool;
            n: bool;
            o: i8;
            is_p_present: bool;
            struct {
                struct {
                    uint8_t buf[5];
                q: };
                is_r_present: bool;
                r: bool;
            p: };
        m: };
    } elements[10];
};

// Type Q in module RustSource.
enum a_rust_source_q_choice_e {
    a_rust_source_q_choice_c001_e,
    a_rust_source_q_choice_c002_e,
    a_rust_source_q_choice_c003_e,
    a_rust_source_q_choice_c004_e,
    a_rust_source_q_choice_c005_e,
    a_rust_source_q_choice_c006_e,
    a_rust_source_q_choice_c007_e,
    a_rust_source_q_choice_c008_e,
    a_rust_source_q_choice_c009_e,
    a_rust_source_q_choice_c010_e,
    a_rust_source_q_choice_c011_e,
    a_rust_source_q_choice_c012_e,
    a_rust_source_q_choice_c013_e,
    a_rust_source_q_choice_c014_e,
    a_rust_source_q_choice_c015_e,
    a_rust_source_q_choice_c016_e,
    a_rust_source_q_choice_c017_e,
    a_rust_source_q_choice_c018_e,
    a_rust_source_q_choice_c019_e,
    a_rust_source_q_choice_c020_e,
    a_rust_source_q_choice_c021_e,
    a_rust_source_q_choice_c022_e,
    a_rust_source_q_choice_c023_e,
    a_rust_source_q_choice_c024_e,
    a_rust_source_q_choice_c025_e,
    a_rust_source_q_choice_c026_e,
    a_rust_source_q_choice_c027_e,
    a_rust_source_q_choice_c028_e,
    a_rust_source_q_choice_c029_e,
    a_rust_source_q_choice_c030_e,
    a_rust_source_q_choice_c031_e,
    a_rust_source_q_choice_c032_e,
    a_rust_source_q_choice_c033_e,
    a_rust_source_q_choice_c034_e,
    a_rust_source_q_choice_c035_e,
    a_rust_source_q_choice_c036_e,
    a_rust_source_q_choice_c037_e,
    a_rust_source_q_choice_c038_e,
    a_rust_source_q_choice_c039_e,
    a_rust_source_q_choice_c040_e,
    a_rust_source_q_choice_c041_e,
    a_rust_source_q_choice_c042_e,
    a_rust_source_q_choice_c043_e,
    a_rust_source_q_choice_c044_e,
    a_rust_source_q_choice_c045_e,
    a_rust_source_q_choice_c046_e,
    a_rust_source_q_choice_c047_e,
    a_rust_source_q_choice_c048_e,
    a_rust_source_q_choice_c049_e,
    a_rust_source_q_choice_c050_e,
    a_rust_source_q_choice_c051_e,
    a_rust_source_q_choice_c052_e,
    a_rust_source_q_choice_c053_e,
    a_rust_source_q_choice_c054_e,
    a_rust_source_q_choice_c055_e,
    a_rust_source_q_choice_c056_e,
    a_rust_source_q_choice_c057_e,
    a_rust_source_q_choice_c058_e,
    a_rust_source_q_choice_c059_e,
    a_rust_source_q_choice_c060_e,
    a_rust_source_q_choice_c061_e,
    a_rust_source_q_choice_c062_e,
    a_rust_source_q_choice_c063_e,
    a_rust_source_q_choice_c064_e,
    a_rust_source_q_choice_c065_e,
    a_rust_source_q_choice_c066_e,
    a_rust_source_q_choice_c067_e,
    a_rust_source_q_choice_c068_e,
    a_rust_source_q_choice_c069_e,
    a_rust_source_q_choice_c070_e,
    a_rust_source_q_choice_c071_e,
    a_rust_source_q_choice_c072_e,
    a_rust_source_q_choice_c073_e,
    a_rust_source_q_choice_c074_e,
    a_rust_source_q_choice_c075_e,
    a_rust_source_q_choice_c076_e,
    a_rust_source_q_choice_c077_e,
    a_rust_source_q_choice_c078_e,
    a_rust_source_q_choice_c079_e,
    a_rust_source_q_choice_c080_e,
    a_rust_source_q_choice_c081_e,
    a_rust_source_q_choice_c082_e,
    a_rust_source_q_choice_c083_e,
    a_rust_source_q_choice_c084_e,
    a_rust_source_q_choice_c085_e,
    a_rust_source_q_choice_c086_e,
    a_rust_source_q_choice_c087_e,
    a_rust_source_q_choice_c088_e,
    a_rust_source_q_choice_c089_e,
    a_rust_source_q_choice_c090_e,
    a_rust_source_q_choice_c091_e,
    a_rust_source_q_choice_c092_e,
    a_rust_source_q_choice_c093_e,
    a_rust_source_q_choice_c094_e,
    a_rust_source_q_choice_c095_e,
    a_rust_source_q_choice_c096_e,
    a_rust_source_q_choice_c097_e,
    a_rust_source_q_choice_c098_e,
    a_rust_source_q_choice_c099_e,
    a_rust_source_q_choice_c100_e,
    a_rust_source_q_choice_c101_e,
    a_rust_source_q_choice_c102_e,
    a_rust_source_q_choice_c103_e,
    a_rust_source_q_choice_c104_e,
    a_rust_source_q_choice_c105_e,
    a_rust_source_q_choice_c106_e,
    a_rust_source_q_choice_c107_e,
    a_rust_source_q_choice_c108_e,
    a_rust_source_q_choice_c109_e,
    a_rust_source_q_choice_c110_e,
    a_rust_source_q_choice_c111_e,
    a_rust_source_q_choice_c112_e,
    a_rust_source_q_choice_c113_e,
    a_rust_source_q_choice_c114_e,
    a_rust_source_q_choice_c115_e,
    a_rust_source_q_choice_c116_e,
    a_rust_source_q_choice_c117_e,
    a_rust_source_q_choice_c118_e,
    a_rust_source_q_choice_c119_e,
    a_rust_source_q_choice_c120_e,
    a_rust_source_q_choice_c121_e,
    a_rust_source_q_choice_c122_e,
    a_rust_source_q_choice_c123_e,
    a_rust_source_q_choice_c124_e,
    a_rust_source_q_choice_c125_e,
    a_rust_source_q_choice_c126_e,
    a_rust_source_q_choice_c127_e,
    a_rust_source_q_choice_c128_e,
    a_rust_source_q_choice_c129_e,
    a_rust_source_q_choice_c130_e,
    a_rust_source_q_choice_c131_e,
    a_rust_source_q_choice_c132_e,
    a_rust_source_q_choice_c133_e,
    a_rust_source_q_choice_c134_e,
    a_rust_source_q_choice_c135_e,
    a_rust_source_q_choice_c136_e,
    a_rust_source_q_choice_c137_e,
    a_rust_source_q_choice_c138_e,
    a_rust_source_q_choice_c139_e,
    a_rust_source_q_choice_c140_e,
    a_rust_source_q_choice_c141_e,
    a_rust_source_q_choice_c142_e,
    a_rust_source_q_choice_c143_e,
    a_rust_source_q_choice_c144_e,
    a_rust_source_q_choice_c145_e,
    a_rust_source_q_choice_c146_e,
    a_rust_source_q_choice_c147_e,
    a_rust_source_q_choice_c148_e,
    a_rust_source_q_choice_c149_e,
    a_rust_source_q_choice_c150_e,
    a_rust_source_q_choice_c151_e,
    a_rust_source_q_choice_c152_e,
    a_rust_source_q_choice_c153_e,
    a_rust_source_q_choice_c154_e,
    a_rust_source_q_choice_c155_e,
    a_rust_source_q_choice_c156_e,
    a_rust_source_q_choice_c157_e,
    a_rust_source_q_choice_c158_e,
    a_rust_source_q_choice_c159_e,
    a_rust_source_q_choice_c160_e,
    a_rust_source_q_choice_c161_e,
    a_rust_source_q_choice_c162_e,
    a_rust_source_q_choice_c163_e,
    a_rust_source_q_choice_c164_e,
    a_rust_source_q_choice_c165_e,
    a_rust_source_q_choice_c166_e,
    a_rust_source_q_choice_c167_e,
    a_rust_source_q_choice_c168_e,
    a_rust_source_q_choice_c169_e,
    a_rust_source_q_choice_c170_e,
    a_rust_source_q_choice_c171_e,
    a_rust_source_q_choice_c172_e,
    a_rust_source_q_choice_c173_e,
    a_rust_source_q_choice_c174_e,
    a_rust_source_q_choice_c175_e,
    a_rust_source_q_choice_c176_e,
    a_rust_source_q_choice_c177_e,
    a_rust_source_q_choice_c178_e,
    a_rust_source_q_choice_c179_e,
    a_rust_source_q_choice_c180_e,
    a_rust_source_q_choice_c181_e,
    a_rust_source_q_choice_c182_e,
    a_rust_source_q_choice_c183_e,
    a_rust_source_q_choice_c184_e,
    a_rust_source_q_choice_c185_e,
    a_rust_source_q_choice_c186_e,
    a_rust_source_q_choice_c187_e,
    a_rust_source_q_choice_c188_e,
    a_rust_source_q_choice_c189_e,
    a_rust_source_q_choice_c190_e,
    a_rust_source_q_choice_c191_e,
    a_rust_source_q_choice_c192_e,
    a_rust_source_q_choice_c193_e,
    a_rust_source_q_choice_c194_e,
    a_rust_source_q_choice_c195_e,
    a_rust_source_q_choice_c196_e,
    a_rust_source_q_choice_c197_e,
    a_rust_source_q_choice_c198_e,
    a_rust_source_q_choice_c199_e,
    a_rust_source_q_choice_c200_e,
    a_rust_source_q_choice_c201_e,
    a_rust_source_q_choice_c202_e,
    a_rust_source_q_choice_c203_e,
    a_rust_source_q_choice_c204_e,
    a_rust_source_q_choice_c205_e,
    a_rust_source_q_choice_c206_e,
    a_rust_source_q_choice_c207_e,
    a_rust_source_q_choice_c208_e,
    a_rust_source_q_choice_c209_e,
    a_rust_source_q_choice_c210_e,
    a_rust_source_q_choice_c211_e,
    a_rust_source_q_choice_c212_e,
    a_rust_source_q_choice_c213_e,
    a_rust_source_q_choice_c214_e,
    a_rust_source_q_choice_c215_e,
    a_rust_source_q_choice_c216_e,
    a_rust_source_q_choice_c217_e,
    a_rust_source_q_choice_c218_e,
    a_rust_source_q_choice_c219_e,
    a_rust_source_q_choice_c220_e,
    a_rust_source_q_choice_c221_e,
    a_rust_source_q_choice_c222_e,
    a_rust_source_q_choice_c223_e,
    a_rust_source_q_choice_c224_e,
    a_rust_source_q_choice_c225_e,
    a_rust_source_q_choice_c226_e,
    a_rust_source_q_choice_c227_e,
    a_rust_source_q_choice_c228_e,
    a_rust_source_q_choice_c229_e,
    a_rust_source_q_choice_c230_e,
    a_rust_source_q_choice_c231_e,
    a_rust_source_q_choice_c232_e,
    a_rust_source_q_choice_c233_e,
    a_rust_source_q_choice_c234_e,
    a_rust_source_q_choice_c235_e,
    a_rust_source_q_choice_c236_e,
    a_rust_source_q_choice_c237_e,
    a_rust_source_q_choice_c238_e,
    a_rust_source_q_choice_c239_e,
    a_rust_source_q_choice_c240_e,
    a_rust_source_q_choice_c241_e,
    a_rust_source_q_choice_c242_e,
    a_rust_source_q_choice_c243_e,
    a_rust_source_q_choice_c244_e,
    a_rust_source_q_choice_c245_e,
    a_rust_source_q_choice_c246_e,
    a_rust_source_q_choice_c247_e,
    a_rust_source_q_choice_c248_e,
    a_rust_source_q_choice_c249_e,
    a_rust_source_q_choice_c250_e,
    a_rust_source_q_choice_c251_e,
    a_rust_source_q_choice_c252_e,
    a_rust_source_q_choice_c253_e,
    a_rust_source_q_choice_c254_e,
    a_rust_source_q_choice_c255_e,
    a_rust_source_q_choice_c256_e,
    a_rust_source_q_choice_c257_e
};

struct RustSourceQ {
    enum a_rust_source_q_choice_e choice;
    union {
        bool c001;
        bool c002;
        bool c003;
        bool c004;
        bool c005;
        bool c006;
        bool c007;
        bool c008;
        bool c009;
        bool c010;
        bool c011;
        bool c012;
        bool c013;
        bool c014;
        bool c015;
        bool c016;
        bool c017;
        bool c018;
        bool c019;
        bool c020;
        bool c021;
        bool c022;
        bool c023;
        bool c024;
        bool c025;
        bool c026;
        bool c027;
        bool c028;
        bool c029;
        bool c030;
        bool c031;
        bool c032;
        bool c033;
        bool c034;
        bool c035;
        bool c036;
        bool c037;
        bool c038;
        bool c039;
        bool c040;
        bool c041;
        bool c042;
        bool c043;
        bool c044;
        bool c045;
        bool c046;
        bool c047;
        bool c048;
        bool c049;
        bool c050;
        bool c051;
        bool c052;
        bool c053;
        bool c054;
        bool c055;
        bool c056;
        bool c057;
        bool c058;
        bool c059;
        bool c060;
        bool c061;
        bool c062;
        bool c063;
        bool c064;
        bool c065;
        bool c066;
        bool c067;
        bool c068;
        bool c069;
        bool c070;
        bool c071;
        bool c072;
        bool c073;
        bool c074;
        bool c075;
        bool c076;
        bool c077;
        bool c078;
        bool c079;
        bool c080;
        bool c081;
        bool c082;
        bool c083;
        bool c084;
        bool c085;
        bool c086;
        bool c087;
        bool c088;
        bool c089;
        bool c090;
        bool c091;
        bool c092;
        bool c093;
        bool c094;
        bool c095;
        bool c096;
        bool c097;
        bool c098;
        bool c099;
        bool c100;
        bool c101;
        bool c102;
        bool c103;
        bool c104;
        bool c105;
        bool c106;
        bool c107;
        bool c108;
        bool c109;
        bool c110;
        bool c111;
        bool c112;
        bool c113;
        bool c114;
        bool c115;
        bool c116;
        bool c117;
        bool c118;
        bool c119;
        bool c120;
        bool c121;
        bool c122;
        bool c123;
        bool c124;
        bool c125;
        bool c126;
        bool c127;
        bool c128;
        bool c129;
        bool c130;
        bool c131;
        bool c132;
        bool c133;
        bool c134;
        bool c135;
        bool c136;
        bool c137;
        bool c138;
        bool c139;
        bool c140;
        bool c141;
        bool c142;
        bool c143;
        bool c144;
        bool c145;
        bool c146;
        bool c147;
        bool c148;
        bool c149;
        bool c150;
        bool c151;
        bool c152;
        bool c153;
        bool c154;
        bool c155;
        bool c156;
        bool c157;
        bool c158;
        bool c159;
        bool c160;
        bool c161;
        bool c162;
        bool c163;
        bool c164;
        bool c165;
        bool c166;
        bool c167;
        bool c168;
        bool c169;
        bool c170;
        bool c171;
        bool c172;
        bool c173;
        bool c174;
        bool c175;
        bool c176;
        bool c177;
        bool c178;
        bool c179;
        bool c180;
        bool c181;
        bool c182;
        bool c183;
        bool c184;
        bool c185;
        bool c186;
        bool c187;
        bool c188;
        bool c189;
        bool c190;
        bool c191;
        bool c192;
        bool c193;
        bool c194;
        bool c195;
        bool c196;
        bool c197;
        bool c198;
        bool c199;
        bool c200;
        bool c201;
        bool c202;
        bool c203;
        bool c204;
        bool c205;
        bool c206;
        bool c207;
        bool c208;
        bool c209;
        bool c210;
        bool c211;
        bool c212;
        bool c213;
        bool c214;
        bool c215;
        bool c216;
        bool c217;
        bool c218;
        bool c219;
        bool c220;
        bool c221;
        bool c222;
        bool c223;
        bool c224;
        bool c225;
        bool c226;
        bool c227;
        bool c228;
        bool c229;
        bool c230;
        bool c231;
        bool c232;
        bool c233;
        bool c234;
        bool c235;
        bool c236;
        bool c237;
        bool c238;
        bool c239;
        bool c240;
        bool c241;
        bool c242;
        bool c243;
        bool c244;
        bool c245;
        bool c246;
        bool c247;
        bool c248;
        bool c249;
        bool c250;
        bool c251;
        bool c252;
        bool c253;
        bool c254;
        bool c255;
        bool c256;
        bool c257;
    } value;
};

// Type AC in module RustSource.
struct RustSourceAC {
    a: struct a_rust_source_q_t;
    b: struct a_rust_source_d_t;
};

// Type B in module RustSource.
enum a_rust_source_b_choice_e {
    a_rust_source_b_choice_a_e,
    a_rust_source_b_choice_b_e,
    a_rust_source_b_choice_c_e
};

struct RustSourceB {
    enum a_rust_source_b_choice_e choice;
    union {
        i8 a;
        struct a_rust_source_a_t b;
    } value;
};

// Type C in module RustSource.
struct RustSourceC {
    let length: u8;
    struct a_rust_source_b_t elements[2];
};

// Type E in module RustSource.
enum a_rust_source_e_a_b_choice_e {
    a_rust_source_e_a_b_choice_c_e
};

enum a_rust_source_e_a_choice_e {
    a_rust_source_e_a_choice_b_e
};

struct RustSourceE {
    struct {
        enum a_rust_source_e_a_choice_e choice;
        union {
            struct {
                enum a_rust_source_e_a_b_choice_e choice;
                union {
                    bool c;
                } value;
            } b;
        } value;
    a: };
};

// Type F in module RustSource.
struct RustSourceF {
    let length: u8;
    struct {
        bool elements[1];
    } elements[2];
};

// Type G in module RustSource.
struct RustSourceG {
    is_a_present: bool;
    a: bool;
    is_b_present: bool;
    b: bool;
    is_c_present: bool;
    c: bool;
    is_d_present: bool;
    d: bool;
    is_e_present: bool;
    e: bool;
    is_f_present: bool;
    f: bool;
    is_g_present: bool;
    g: bool;
    is_h_present: bool;
    h: bool;
    is_i_present: bool;
    i: bool;
};

// Type H in module RustSource.
struct RustSourceH {
    dummy: u8;
};

// Type I in module RustSource.
struct RustSourceI {
    uint8_t buf[24];
};

// Type J in module RustSource.
struct RustSourceJ {
    let length: u8;
    uint8_t buf[23];
};

// Type K in module RustSource.
enum a_rust_source_k_e {
    a_rust_source_k_a_e
};

struct RustSourceK {
    enum a_rust_source_k_e value;
};

// Type L in module RustSource.
struct RustSourceL {
    let length: u32;
    uint8_t buf[500];
};

// Type O in module RustSource.
struct RustSourceO {
    let length: u32;
    bool elements[260];
};

// Type N in module RustSource.
struct RustSourceN {
    a: struct a_rust_source_k_t;
    b: struct a_rust_source_a_t;
    c: struct a_rust_source_o_t;
};

// Type M in module RustSource.
struct RustSourceM {
    a: struct a_rust_source_k_t;
    b: struct a_rust_source_n_t;
};

// Type P in module RustSource.
struct RustSourceP {
    a: struct a_rust_source_a_t;
    b: struct a_rust_source_m_t;
    c: struct a_rust_source_f_t;
};

// Type R in module RustSource.
struct RustSourceR {
    i8 value;
};

// Type S in module RustSource.
struct RustSourceS {
    i8 value;
};

// Type T in module RustSource.
struct RustSourceT {
    i8 value;
};

// Type U in module RustSource.
struct RustSourceU {
    i8 value;
};

// Type V in module RustSource.
struct RustSourceV {
    i8 value;
};

// Type W in module RustSource.
struct RustSourceW {
    i16 value;
};

// Type X in module RustSource.
struct RustSourceX {
    i16 value;
};

// Type Y in module RustSource.
struct RustSourceY {
    u16 value;
};

// Type Z in module RustSource.
struct RustSourceZ {
    bool value;
};

impl RustSourceA {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_i8(self.a);
        encoder.append_i16(self.b);
        encoder.append_i32(self.c);
        encoder.append_i64(self.d);
        encoder.append_u8(self.e);
        encoder.append_u16(self.f);
        encoder.append_u32(self.g);
        encoder.append_u64(self.h);
        encoder.append_bool(self.i);
        encoder.append_bytes(&self.j.buf,
                             11);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.a = decoder.read_i8();
        self.b = decoder.read_i16();
        self.c = decoder.read_i32();
        self.d = decoder.read_i64();
        self.e = decoder.read_u8();
        self.f = decoder.read_u16();
        self.g = decoder.read_u32();
        self.h = decoder.read_u64();
        self.i = decoder.read_bool();
        decoder.read_bytes(&mut self.j.buf,
                           11);
    }
}

impl RustSourceAB {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (uint64_t)(self.a - -1),
            1);
        encoder.append_non_negative_binary_integer(
            (uint64_t)(self.b - 10000),
            10);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.a = decoder.read_non_negative_binary_integer(1);
        self.a += -1;
        self.b = decoder.read_non_negative_binary_integer(10);
        self.b += 10000;
    }
}

impl RustSourceD {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        u8 i;
        u8 i_2;

        encoder.append_non_negative_binary_integer(
            self.length - 1u,
            4);

        for i in 0..self.length {
            match self.elements[i].a.b.choice {

                a_rust_source_d_a_b_choice_c_e => {
                    encoder.append_non_negative_binary_integer(0, 1);
                    encoder.append_non_negative_binary_integer(
                        (uint64_t)(self.elements[i].a.b.value.c - 0),
                        1);
                }

                a_rust_source_d_a_b_choice_d_e => {
                    encoder.append_non_negative_binary_integer(1, 1);
                    encoder.append_bool(self.elements[i].a.b.value.d);
                }

                _ => encoder.abort(EBADCHOICE);
            }

            encoder.append_non_negative_binary_integer(
                self.elements[i].a.e.length - 3u,
                1);

            for i_2 in 0..self.elements[i].a.e.length {
            }

            encoder.append_non_negative_binary_integer(self.elements[i].g.h, 2);
            encoder.append_non_negative_binary_integer(
                self.elements[i].g.l.length - 1u,
                1);
            encoder.append_bytes(&self.elements[i].g.l.buf,
                                 self.elements[i].g.l.length);
            encoder.append_bit(self.elements[i].m.is_n_present as u8);
            encoder.append_bit((self.elements[i].m.o != 3) as u8);
            encoder.append_bit(self.elements[i].m.is_p_present as u8);

            if src.elements[i].m.is_n_present {
                encoder.append_bool(self.elements[i].m.n);
            }

            if src.elements[i].m.o != 3 {
                encoder.append_non_negative_binary_integer(
                    (uint64_t)(self.elements[i].m.o - -2),
                    3);
            }

            if src.elements[i].m.is_p_present {
                encoder.append_bit(self.elements[i].m.p.is_r_present as u8);
                encoder.append_bytes(&self.elements[i].m.p.q.buf,
                                     5);

                if src.elements[i].m.p.is_r_present {
                    encoder.append_bool(self.elements[i].m.p.r);
                }
            }
        }
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        u8 i;
        u8 choice;
        u8 i_2;
        bool is_present;

        self.length = decoder.read_non_negative_binary_integer(4);
        self.length += 1;

        if self.length > 10 {
            decoder.abort(EBADLENGTH);

            return;
        }

        for i in 0..self.length {
            choice = decoder.read_non_negative_binary_integer(1);

            match choice {

                0 => {
                    self.elements[i].a.b.choice = a_rust_source_d_a_b_choice_c_e;
                    self.elements[i].a.b.value.c = decoder.read_non_negative_binary_integer(1);
                    self.elements[i].a.b.value.c += 0;
                }

                1 => {
                    self.elements[i].a.b.choice = a_rust_source_d_a_b_choice_d_e;
                    self.elements[i].a.b.value.d = decoder.read_bool();
                }

                _ => decoder.abort(EBADCHOICE);
            }

            self.elements[i].a.e.length = decoder.read_non_negative_binary_integer(1);
            self.elements[i].a.e.length += 3;

            for i_2 in 0..self.elements[i].a.e.length {
            }

            self.elements[i].g.h = decoder.read_non_negative_binary_integer(2);
            self.elements[i].g.l.length = decoder.read_non_negative_binary_integer(
                1);
            self.elements[i].g.l.length += 1;
            decoder.read_bytes(&mut self.elements[i].g.l.buf,
                               self.elements[i].g.l.length);
            self.elements[i].m.is_n_present = decoder.read_bit() != 0;
            is_present = decoder.read_bit() == 1;
            self.elements[i].m.is_p_present = decoder.read_bit() != 0;

            if dst.elements[i].m.is_n_present {
                self.elements[i].m.n = decoder.read_bool();
            }

            if is_present {
                self.elements[i].m.o = decoder.read_non_negative_binary_integer(3);
                self.elements[i].m.o += -2;
            } else {
                dst.elements[i].m.o = 3;
            }

            if dst.elements[i].m.is_p_present {
                self.elements[i].m.p.is_r_present = decoder.read_bit() != 0;
                decoder.read_bytes(&mut self.elements[i].m.p.q.buf,
                                   5);

                if dst.elements[i].m.p.is_r_present {
                    self.elements[i].m.p.r = decoder.read_bool();
                }
            }
        }
    }
}

impl RustSourceQ {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        match self.choice {

            a_rust_source_q_choice_c001_e => {
                encoder.append_non_negative_binary_integer(0, 9);
                encoder.append_bool(self.value.c001);
            }

            a_rust_source_q_choice_c002_e => {
                encoder.append_non_negative_binary_integer(1, 9);
                encoder.append_bool(self.value.c002);
            }

            a_rust_source_q_choice_c003_e => {
                encoder.append_non_negative_binary_integer(2, 9);
                encoder.append_bool(self.value.c003);
            }

            a_rust_source_q_choice_c004_e => {
                encoder.append_non_negative_binary_integer(3, 9);
                encoder.append_bool(self.value.c004);
            }

            a_rust_source_q_choice_c005_e => {
                encoder.append_non_negative_binary_integer(4, 9);
                encoder.append_bool(self.value.c005);
            }

            a_rust_source_q_choice_c006_e => {
                encoder.append_non_negative_binary_integer(5, 9);
                encoder.append_bool(self.value.c006);
            }

            a_rust_source_q_choice_c007_e => {
                encoder.append_non_negative_binary_integer(6, 9);
                encoder.append_bool(self.value.c007);
            }

            a_rust_source_q_choice_c008_e => {
                encoder.append_non_negative_binary_integer(7, 9);
                encoder.append_bool(self.value.c008);
            }

            a_rust_source_q_choice_c009_e => {
                encoder.append_non_negative_binary_integer(8, 9);
                encoder.append_bool(self.value.c009);
            }

            a_rust_source_q_choice_c010_e => {
                encoder.append_non_negative_binary_integer(9, 9);
                encoder.append_bool(self.value.c010);
            }

            a_rust_source_q_choice_c011_e => {
                encoder.append_non_negative_binary_integer(10, 9);
                encoder.append_bool(self.value.c011);
            }

            a_rust_source_q_choice_c012_e => {
                encoder.append_non_negative_binary_integer(11, 9);
                encoder.append_bool(self.value.c012);
            }

            a_rust_source_q_choice_c013_e => {
                encoder.append_non_negative_binary_integer(12, 9);
                encoder.append_bool(self.value.c013);
            }

            a_rust_source_q_choice_c014_e => {
                encoder.append_non_negative_binary_integer(13, 9);
                encoder.append_bool(self.value.c014);
            }

            a_rust_source_q_choice_c015_e => {
                encoder.append_non_negative_binary_integer(14, 9);
                encoder.append_bool(self.value.c015);
            }

            a_rust_source_q_choice_c016_e => {
                encoder.append_non_negative_binary_integer(15, 9);
                encoder.append_bool(self.value.c016);
            }

            a_rust_source_q_choice_c017_e => {
                encoder.append_non_negative_binary_integer(16, 9);
                encoder.append_bool(self.value.c017);
            }

            a_rust_source_q_choice_c018_e => {
                encoder.append_non_negative_binary_integer(17, 9);
                encoder.append_bool(self.value.c018);
            }

            a_rust_source_q_choice_c019_e => {
                encoder.append_non_negative_binary_integer(18, 9);
                encoder.append_bool(self.value.c019);
            }

            a_rust_source_q_choice_c020_e => {
                encoder.append_non_negative_binary_integer(19, 9);
                encoder.append_bool(self.value.c020);
            }

            a_rust_source_q_choice_c021_e => {
                encoder.append_non_negative_binary_integer(20, 9);
                encoder.append_bool(self.value.c021);
            }

            a_rust_source_q_choice_c022_e => {
                encoder.append_non_negative_binary_integer(21, 9);
                encoder.append_bool(self.value.c022);
            }

            a_rust_source_q_choice_c023_e => {
                encoder.append_non_negative_binary_integer(22, 9);
                encoder.append_bool(self.value.c023);
            }

            a_rust_source_q_choice_c024_e => {
                encoder.append_non_negative_binary_integer(23, 9);
                encoder.append_bool(self.value.c024);
            }

            a_rust_source_q_choice_c025_e => {
                encoder.append_non_negative_binary_integer(24, 9);
                encoder.append_bool(self.value.c025);
            }

            a_rust_source_q_choice_c026_e => {
                encoder.append_non_negative_binary_integer(25, 9);
                encoder.append_bool(self.value.c026);
            }

            a_rust_source_q_choice_c027_e => {
                encoder.append_non_negative_binary_integer(26, 9);
                encoder.append_bool(self.value.c027);
            }

            a_rust_source_q_choice_c028_e => {
                encoder.append_non_negative_binary_integer(27, 9);
                encoder.append_bool(self.value.c028);
            }

            a_rust_source_q_choice_c029_e => {
                encoder.append_non_negative_binary_integer(28, 9);
                encoder.append_bool(self.value.c029);
            }

            a_rust_source_q_choice_c030_e => {
                encoder.append_non_negative_binary_integer(29, 9);
                encoder.append_bool(self.value.c030);
            }

            a_rust_source_q_choice_c031_e => {
                encoder.append_non_negative_binary_integer(30, 9);
                encoder.append_bool(self.value.c031);
            }

            a_rust_source_q_choice_c032_e => {
                encoder.append_non_negative_binary_integer(31, 9);
                encoder.append_bool(self.value.c032);
            }

            a_rust_source_q_choice_c033_e => {
                encoder.append_non_negative_binary_integer(32, 9);
                encoder.append_bool(self.value.c033);
            }

            a_rust_source_q_choice_c034_e => {
                encoder.append_non_negative_binary_integer(33, 9);
                encoder.append_bool(self.value.c034);
            }

            a_rust_source_q_choice_c035_e => {
                encoder.append_non_negative_binary_integer(34, 9);
                encoder.append_bool(self.value.c035);
            }

            a_rust_source_q_choice_c036_e => {
                encoder.append_non_negative_binary_integer(35, 9);
                encoder.append_bool(self.value.c036);
            }

            a_rust_source_q_choice_c037_e => {
                encoder.append_non_negative_binary_integer(36, 9);
                encoder.append_bool(self.value.c037);
            }

            a_rust_source_q_choice_c038_e => {
                encoder.append_non_negative_binary_integer(37, 9);
                encoder.append_bool(self.value.c038);
            }

            a_rust_source_q_choice_c039_e => {
                encoder.append_non_negative_binary_integer(38, 9);
                encoder.append_bool(self.value.c039);
            }

            a_rust_source_q_choice_c040_e => {
                encoder.append_non_negative_binary_integer(39, 9);
                encoder.append_bool(self.value.c040);
            }

            a_rust_source_q_choice_c041_e => {
                encoder.append_non_negative_binary_integer(40, 9);
                encoder.append_bool(self.value.c041);
            }

            a_rust_source_q_choice_c042_e => {
                encoder.append_non_negative_binary_integer(41, 9);
                encoder.append_bool(self.value.c042);
            }

            a_rust_source_q_choice_c043_e => {
                encoder.append_non_negative_binary_integer(42, 9);
                encoder.append_bool(self.value.c043);
            }

            a_rust_source_q_choice_c044_e => {
                encoder.append_non_negative_binary_integer(43, 9);
                encoder.append_bool(self.value.c044);
            }

            a_rust_source_q_choice_c045_e => {
                encoder.append_non_negative_binary_integer(44, 9);
                encoder.append_bool(self.value.c045);
            }

            a_rust_source_q_choice_c046_e => {
                encoder.append_non_negative_binary_integer(45, 9);
                encoder.append_bool(self.value.c046);
            }

            a_rust_source_q_choice_c047_e => {
                encoder.append_non_negative_binary_integer(46, 9);
                encoder.append_bool(self.value.c047);
            }

            a_rust_source_q_choice_c048_e => {
                encoder.append_non_negative_binary_integer(47, 9);
                encoder.append_bool(self.value.c048);
            }

            a_rust_source_q_choice_c049_e => {
                encoder.append_non_negative_binary_integer(48, 9);
                encoder.append_bool(self.value.c049);
            }

            a_rust_source_q_choice_c050_e => {
                encoder.append_non_negative_binary_integer(49, 9);
                encoder.append_bool(self.value.c050);
            }

            a_rust_source_q_choice_c051_e => {
                encoder.append_non_negative_binary_integer(50, 9);
                encoder.append_bool(self.value.c051);
            }

            a_rust_source_q_choice_c052_e => {
                encoder.append_non_negative_binary_integer(51, 9);
                encoder.append_bool(self.value.c052);
            }

            a_rust_source_q_choice_c053_e => {
                encoder.append_non_negative_binary_integer(52, 9);
                encoder.append_bool(self.value.c053);
            }

            a_rust_source_q_choice_c054_e => {
                encoder.append_non_negative_binary_integer(53, 9);
                encoder.append_bool(self.value.c054);
            }

            a_rust_source_q_choice_c055_e => {
                encoder.append_non_negative_binary_integer(54, 9);
                encoder.append_bool(self.value.c055);
            }

            a_rust_source_q_choice_c056_e => {
                encoder.append_non_negative_binary_integer(55, 9);
                encoder.append_bool(self.value.c056);
            }

            a_rust_source_q_choice_c057_e => {
                encoder.append_non_negative_binary_integer(56, 9);
                encoder.append_bool(self.value.c057);
            }

            a_rust_source_q_choice_c058_e => {
                encoder.append_non_negative_binary_integer(57, 9);
                encoder.append_bool(self.value.c058);
            }

            a_rust_source_q_choice_c059_e => {
                encoder.append_non_negative_binary_integer(58, 9);
                encoder.append_bool(self.value.c059);
            }

            a_rust_source_q_choice_c060_e => {
                encoder.append_non_negative_binary_integer(59, 9);
                encoder.append_bool(self.value.c060);
            }

            a_rust_source_q_choice_c061_e => {
                encoder.append_non_negative_binary_integer(60, 9);
                encoder.append_bool(self.value.c061);
            }

            a_rust_source_q_choice_c062_e => {
                encoder.append_non_negative_binary_integer(61, 9);
                encoder.append_bool(self.value.c062);
            }

            a_rust_source_q_choice_c063_e => {
                encoder.append_non_negative_binary_integer(62, 9);
                encoder.append_bool(self.value.c063);
            }

            a_rust_source_q_choice_c064_e => {
                encoder.append_non_negative_binary_integer(63, 9);
                encoder.append_bool(self.value.c064);
            }

            a_rust_source_q_choice_c065_e => {
                encoder.append_non_negative_binary_integer(64, 9);
                encoder.append_bool(self.value.c065);
            }

            a_rust_source_q_choice_c066_e => {
                encoder.append_non_negative_binary_integer(65, 9);
                encoder.append_bool(self.value.c066);
            }

            a_rust_source_q_choice_c067_e => {
                encoder.append_non_negative_binary_integer(66, 9);
                encoder.append_bool(self.value.c067);
            }

            a_rust_source_q_choice_c068_e => {
                encoder.append_non_negative_binary_integer(67, 9);
                encoder.append_bool(self.value.c068);
            }

            a_rust_source_q_choice_c069_e => {
                encoder.append_non_negative_binary_integer(68, 9);
                encoder.append_bool(self.value.c069);
            }

            a_rust_source_q_choice_c070_e => {
                encoder.append_non_negative_binary_integer(69, 9);
                encoder.append_bool(self.value.c070);
            }

            a_rust_source_q_choice_c071_e => {
                encoder.append_non_negative_binary_integer(70, 9);
                encoder.append_bool(self.value.c071);
            }

            a_rust_source_q_choice_c072_e => {
                encoder.append_non_negative_binary_integer(71, 9);
                encoder.append_bool(self.value.c072);
            }

            a_rust_source_q_choice_c073_e => {
                encoder.append_non_negative_binary_integer(72, 9);
                encoder.append_bool(self.value.c073);
            }

            a_rust_source_q_choice_c074_e => {
                encoder.append_non_negative_binary_integer(73, 9);
                encoder.append_bool(self.value.c074);
            }

            a_rust_source_q_choice_c075_e => {
                encoder.append_non_negative_binary_integer(74, 9);
                encoder.append_bool(self.value.c075);
            }

            a_rust_source_q_choice_c076_e => {
                encoder.append_non_negative_binary_integer(75, 9);
                encoder.append_bool(self.value.c076);
            }

            a_rust_source_q_choice_c077_e => {
                encoder.append_non_negative_binary_integer(76, 9);
                encoder.append_bool(self.value.c077);
            }

            a_rust_source_q_choice_c078_e => {
                encoder.append_non_negative_binary_integer(77, 9);
                encoder.append_bool(self.value.c078);
            }

            a_rust_source_q_choice_c079_e => {
                encoder.append_non_negative_binary_integer(78, 9);
                encoder.append_bool(self.value.c079);
            }

            a_rust_source_q_choice_c080_e => {
                encoder.append_non_negative_binary_integer(79, 9);
                encoder.append_bool(self.value.c080);
            }

            a_rust_source_q_choice_c081_e => {
                encoder.append_non_negative_binary_integer(80, 9);
                encoder.append_bool(self.value.c081);
            }

            a_rust_source_q_choice_c082_e => {
                encoder.append_non_negative_binary_integer(81, 9);
                encoder.append_bool(self.value.c082);
            }

            a_rust_source_q_choice_c083_e => {
                encoder.append_non_negative_binary_integer(82, 9);
                encoder.append_bool(self.value.c083);
            }

            a_rust_source_q_choice_c084_e => {
                encoder.append_non_negative_binary_integer(83, 9);
                encoder.append_bool(self.value.c084);
            }

            a_rust_source_q_choice_c085_e => {
                encoder.append_non_negative_binary_integer(84, 9);
                encoder.append_bool(self.value.c085);
            }

            a_rust_source_q_choice_c086_e => {
                encoder.append_non_negative_binary_integer(85, 9);
                encoder.append_bool(self.value.c086);
            }

            a_rust_source_q_choice_c087_e => {
                encoder.append_non_negative_binary_integer(86, 9);
                encoder.append_bool(self.value.c087);
            }

            a_rust_source_q_choice_c088_e => {
                encoder.append_non_negative_binary_integer(87, 9);
                encoder.append_bool(self.value.c088);
            }

            a_rust_source_q_choice_c089_e => {
                encoder.append_non_negative_binary_integer(88, 9);
                encoder.append_bool(self.value.c089);
            }

            a_rust_source_q_choice_c090_e => {
                encoder.append_non_negative_binary_integer(89, 9);
                encoder.append_bool(self.value.c090);
            }

            a_rust_source_q_choice_c091_e => {
                encoder.append_non_negative_binary_integer(90, 9);
                encoder.append_bool(self.value.c091);
            }

            a_rust_source_q_choice_c092_e => {
                encoder.append_non_negative_binary_integer(91, 9);
                encoder.append_bool(self.value.c092);
            }

            a_rust_source_q_choice_c093_e => {
                encoder.append_non_negative_binary_integer(92, 9);
                encoder.append_bool(self.value.c093);
            }

            a_rust_source_q_choice_c094_e => {
                encoder.append_non_negative_binary_integer(93, 9);
                encoder.append_bool(self.value.c094);
            }

            a_rust_source_q_choice_c095_e => {
                encoder.append_non_negative_binary_integer(94, 9);
                encoder.append_bool(self.value.c095);
            }

            a_rust_source_q_choice_c096_e => {
                encoder.append_non_negative_binary_integer(95, 9);
                encoder.append_bool(self.value.c096);
            }

            a_rust_source_q_choice_c097_e => {
                encoder.append_non_negative_binary_integer(96, 9);
                encoder.append_bool(self.value.c097);
            }

            a_rust_source_q_choice_c098_e => {
                encoder.append_non_negative_binary_integer(97, 9);
                encoder.append_bool(self.value.c098);
            }

            a_rust_source_q_choice_c099_e => {
                encoder.append_non_negative_binary_integer(98, 9);
                encoder.append_bool(self.value.c099);
            }

            a_rust_source_q_choice_c100_e => {
                encoder.append_non_negative_binary_integer(99, 9);
                encoder.append_bool(self.value.c100);
            }

            a_rust_source_q_choice_c101_e => {
                encoder.append_non_negative_binary_integer(100, 9);
                encoder.append_bool(self.value.c101);
            }

            a_rust_source_q_choice_c102_e => {
                encoder.append_non_negative_binary_integer(101, 9);
                encoder.append_bool(self.value.c102);
            }

            a_rust_source_q_choice_c103_e => {
                encoder.append_non_negative_binary_integer(102, 9);
                encoder.append_bool(self.value.c103);
            }

            a_rust_source_q_choice_c104_e => {
                encoder.append_non_negative_binary_integer(103, 9);
                encoder.append_bool(self.value.c104);
            }

            a_rust_source_q_choice_c105_e => {
                encoder.append_non_negative_binary_integer(104, 9);
                encoder.append_bool(self.value.c105);
            }

            a_rust_source_q_choice_c106_e => {
                encoder.append_non_negative_binary_integer(105, 9);
                encoder.append_bool(self.value.c106);
            }

            a_rust_source_q_choice_c107_e => {
                encoder.append_non_negative_binary_integer(106, 9);
                encoder.append_bool(self.value.c107);
            }

            a_rust_source_q_choice_c108_e => {
                encoder.append_non_negative_binary_integer(107, 9);
                encoder.append_bool(self.value.c108);
            }

            a_rust_source_q_choice_c109_e => {
                encoder.append_non_negative_binary_integer(108, 9);
                encoder.append_bool(self.value.c109);
            }

            a_rust_source_q_choice_c110_e => {
                encoder.append_non_negative_binary_integer(109, 9);
                encoder.append_bool(self.value.c110);
            }

            a_rust_source_q_choice_c111_e => {
                encoder.append_non_negative_binary_integer(110, 9);
                encoder.append_bool(self.value.c111);
            }

            a_rust_source_q_choice_c112_e => {
                encoder.append_non_negative_binary_integer(111, 9);
                encoder.append_bool(self.value.c112);
            }

            a_rust_source_q_choice_c113_e => {
                encoder.append_non_negative_binary_integer(112, 9);
                encoder.append_bool(self.value.c113);
            }

            a_rust_source_q_choice_c114_e => {
                encoder.append_non_negative_binary_integer(113, 9);
                encoder.append_bool(self.value.c114);
            }

            a_rust_source_q_choice_c115_e => {
                encoder.append_non_negative_binary_integer(114, 9);
                encoder.append_bool(self.value.c115);
            }

            a_rust_source_q_choice_c116_e => {
                encoder.append_non_negative_binary_integer(115, 9);
                encoder.append_bool(self.value.c116);
            }

            a_rust_source_q_choice_c117_e => {
                encoder.append_non_negative_binary_integer(116, 9);
                encoder.append_bool(self.value.c117);
            }

            a_rust_source_q_choice_c118_e => {
                encoder.append_non_negative_binary_integer(117, 9);
                encoder.append_bool(self.value.c118);
            }

            a_rust_source_q_choice_c119_e => {
                encoder.append_non_negative_binary_integer(118, 9);
                encoder.append_bool(self.value.c119);
            }

            a_rust_source_q_choice_c120_e => {
                encoder.append_non_negative_binary_integer(119, 9);
                encoder.append_bool(self.value.c120);
            }

            a_rust_source_q_choice_c121_e => {
                encoder.append_non_negative_binary_integer(120, 9);
                encoder.append_bool(self.value.c121);
            }

            a_rust_source_q_choice_c122_e => {
                encoder.append_non_negative_binary_integer(121, 9);
                encoder.append_bool(self.value.c122);
            }

            a_rust_source_q_choice_c123_e => {
                encoder.append_non_negative_binary_integer(122, 9);
                encoder.append_bool(self.value.c123);
            }

            a_rust_source_q_choice_c124_e => {
                encoder.append_non_negative_binary_integer(123, 9);
                encoder.append_bool(self.value.c124);
            }

            a_rust_source_q_choice_c125_e => {
                encoder.append_non_negative_binary_integer(124, 9);
                encoder.append_bool(self.value.c125);
            }

            a_rust_source_q_choice_c126_e => {
                encoder.append_non_negative_binary_integer(125, 9);
                encoder.append_bool(self.value.c126);
            }

            a_rust_source_q_choice_c127_e => {
                encoder.append_non_negative_binary_integer(126, 9);
                encoder.append_bool(self.value.c127);
            }

            a_rust_source_q_choice_c128_e => {
                encoder.append_non_negative_binary_integer(127, 9);
                encoder.append_bool(self.value.c128);
            }

            a_rust_source_q_choice_c129_e => {
                encoder.append_non_negative_binary_integer(128, 9);
                encoder.append_bool(self.value.c129);
            }

            a_rust_source_q_choice_c130_e => {
                encoder.append_non_negative_binary_integer(129, 9);
                encoder.append_bool(self.value.c130);
            }

            a_rust_source_q_choice_c131_e => {
                encoder.append_non_negative_binary_integer(130, 9);
                encoder.append_bool(self.value.c131);
            }

            a_rust_source_q_choice_c132_e => {
                encoder.append_non_negative_binary_integer(131, 9);
                encoder.append_bool(self.value.c132);
            }

            a_rust_source_q_choice_c133_e => {
                encoder.append_non_negative_binary_integer(132, 9);
                encoder.append_bool(self.value.c133);
            }

            a_rust_source_q_choice_c134_e => {
                encoder.append_non_negative_binary_integer(133, 9);
                encoder.append_bool(self.value.c134);
            }

            a_rust_source_q_choice_c135_e => {
                encoder.append_non_negative_binary_integer(134, 9);
                encoder.append_bool(self.value.c135);
            }

            a_rust_source_q_choice_c136_e => {
                encoder.append_non_negative_binary_integer(135, 9);
                encoder.append_bool(self.value.c136);
            }

            a_rust_source_q_choice_c137_e => {
                encoder.append_non_negative_binary_integer(136, 9);
                encoder.append_bool(self.value.c137);
            }

            a_rust_source_q_choice_c138_e => {
                encoder.append_non_negative_binary_integer(137, 9);
                encoder.append_bool(self.value.c138);
            }

            a_rust_source_q_choice_c139_e => {
                encoder.append_non_negative_binary_integer(138, 9);
                encoder.append_bool(self.value.c139);
            }

            a_rust_source_q_choice_c140_e => {
                encoder.append_non_negative_binary_integer(139, 9);
                encoder.append_bool(self.value.c140);
            }

            a_rust_source_q_choice_c141_e => {
                encoder.append_non_negative_binary_integer(140, 9);
                encoder.append_bool(self.value.c141);
            }

            a_rust_source_q_choice_c142_e => {
                encoder.append_non_negative_binary_integer(141, 9);
                encoder.append_bool(self.value.c142);
            }

            a_rust_source_q_choice_c143_e => {
                encoder.append_non_negative_binary_integer(142, 9);
                encoder.append_bool(self.value.c143);
            }

            a_rust_source_q_choice_c144_e => {
                encoder.append_non_negative_binary_integer(143, 9);
                encoder.append_bool(self.value.c144);
            }

            a_rust_source_q_choice_c145_e => {
                encoder.append_non_negative_binary_integer(144, 9);
                encoder.append_bool(self.value.c145);
            }

            a_rust_source_q_choice_c146_e => {
                encoder.append_non_negative_binary_integer(145, 9);
                encoder.append_bool(self.value.c146);
            }

            a_rust_source_q_choice_c147_e => {
                encoder.append_non_negative_binary_integer(146, 9);
                encoder.append_bool(self.value.c147);
            }

            a_rust_source_q_choice_c148_e => {
                encoder.append_non_negative_binary_integer(147, 9);
                encoder.append_bool(self.value.c148);
            }

            a_rust_source_q_choice_c149_e => {
                encoder.append_non_negative_binary_integer(148, 9);
                encoder.append_bool(self.value.c149);
            }

            a_rust_source_q_choice_c150_e => {
                encoder.append_non_negative_binary_integer(149, 9);
                encoder.append_bool(self.value.c150);
            }

            a_rust_source_q_choice_c151_e => {
                encoder.append_non_negative_binary_integer(150, 9);
                encoder.append_bool(self.value.c151);
            }

            a_rust_source_q_choice_c152_e => {
                encoder.append_non_negative_binary_integer(151, 9);
                encoder.append_bool(self.value.c152);
            }

            a_rust_source_q_choice_c153_e => {
                encoder.append_non_negative_binary_integer(152, 9);
                encoder.append_bool(self.value.c153);
            }

            a_rust_source_q_choice_c154_e => {
                encoder.append_non_negative_binary_integer(153, 9);
                encoder.append_bool(self.value.c154);
            }

            a_rust_source_q_choice_c155_e => {
                encoder.append_non_negative_binary_integer(154, 9);
                encoder.append_bool(self.value.c155);
            }

            a_rust_source_q_choice_c156_e => {
                encoder.append_non_negative_binary_integer(155, 9);
                encoder.append_bool(self.value.c156);
            }

            a_rust_source_q_choice_c157_e => {
                encoder.append_non_negative_binary_integer(156, 9);
                encoder.append_bool(self.value.c157);
            }

            a_rust_source_q_choice_c158_e => {
                encoder.append_non_negative_binary_integer(157, 9);
                encoder.append_bool(self.value.c158);
            }

            a_rust_source_q_choice_c159_e => {
                encoder.append_non_negative_binary_integer(158, 9);
                encoder.append_bool(self.value.c159);
            }

            a_rust_source_q_choice_c160_e => {
                encoder.append_non_negative_binary_integer(159, 9);
                encoder.append_bool(self.value.c160);
            }

            a_rust_source_q_choice_c161_e => {
                encoder.append_non_negative_binary_integer(160, 9);
                encoder.append_bool(self.value.c161);
            }

            a_rust_source_q_choice_c162_e => {
                encoder.append_non_negative_binary_integer(161, 9);
                encoder.append_bool(self.value.c162);
            }

            a_rust_source_q_choice_c163_e => {
                encoder.append_non_negative_binary_integer(162, 9);
                encoder.append_bool(self.value.c163);
            }

            a_rust_source_q_choice_c164_e => {
                encoder.append_non_negative_binary_integer(163, 9);
                encoder.append_bool(self.value.c164);
            }

            a_rust_source_q_choice_c165_e => {
                encoder.append_non_negative_binary_integer(164, 9);
                encoder.append_bool(self.value.c165);
            }

            a_rust_source_q_choice_c166_e => {
                encoder.append_non_negative_binary_integer(165, 9);
                encoder.append_bool(self.value.c166);
            }

            a_rust_source_q_choice_c167_e => {
                encoder.append_non_negative_binary_integer(166, 9);
                encoder.append_bool(self.value.c167);
            }

            a_rust_source_q_choice_c168_e => {
                encoder.append_non_negative_binary_integer(167, 9);
                encoder.append_bool(self.value.c168);
            }

            a_rust_source_q_choice_c169_e => {
                encoder.append_non_negative_binary_integer(168, 9);
                encoder.append_bool(self.value.c169);
            }

            a_rust_source_q_choice_c170_e => {
                encoder.append_non_negative_binary_integer(169, 9);
                encoder.append_bool(self.value.c170);
            }

            a_rust_source_q_choice_c171_e => {
                encoder.append_non_negative_binary_integer(170, 9);
                encoder.append_bool(self.value.c171);
            }

            a_rust_source_q_choice_c172_e => {
                encoder.append_non_negative_binary_integer(171, 9);
                encoder.append_bool(self.value.c172);
            }

            a_rust_source_q_choice_c173_e => {
                encoder.append_non_negative_binary_integer(172, 9);
                encoder.append_bool(self.value.c173);
            }

            a_rust_source_q_choice_c174_e => {
                encoder.append_non_negative_binary_integer(173, 9);
                encoder.append_bool(self.value.c174);
            }

            a_rust_source_q_choice_c175_e => {
                encoder.append_non_negative_binary_integer(174, 9);
                encoder.append_bool(self.value.c175);
            }

            a_rust_source_q_choice_c176_e => {
                encoder.append_non_negative_binary_integer(175, 9);
                encoder.append_bool(self.value.c176);
            }

            a_rust_source_q_choice_c177_e => {
                encoder.append_non_negative_binary_integer(176, 9);
                encoder.append_bool(self.value.c177);
            }

            a_rust_source_q_choice_c178_e => {
                encoder.append_non_negative_binary_integer(177, 9);
                encoder.append_bool(self.value.c178);
            }

            a_rust_source_q_choice_c179_e => {
                encoder.append_non_negative_binary_integer(178, 9);
                encoder.append_bool(self.value.c179);
            }

            a_rust_source_q_choice_c180_e => {
                encoder.append_non_negative_binary_integer(179, 9);
                encoder.append_bool(self.value.c180);
            }

            a_rust_source_q_choice_c181_e => {
                encoder.append_non_negative_binary_integer(180, 9);
                encoder.append_bool(self.value.c181);
            }

            a_rust_source_q_choice_c182_e => {
                encoder.append_non_negative_binary_integer(181, 9);
                encoder.append_bool(self.value.c182);
            }

            a_rust_source_q_choice_c183_e => {
                encoder.append_non_negative_binary_integer(182, 9);
                encoder.append_bool(self.value.c183);
            }

            a_rust_source_q_choice_c184_e => {
                encoder.append_non_negative_binary_integer(183, 9);
                encoder.append_bool(self.value.c184);
            }

            a_rust_source_q_choice_c185_e => {
                encoder.append_non_negative_binary_integer(184, 9);
                encoder.append_bool(self.value.c185);
            }

            a_rust_source_q_choice_c186_e => {
                encoder.append_non_negative_binary_integer(185, 9);
                encoder.append_bool(self.value.c186);
            }

            a_rust_source_q_choice_c187_e => {
                encoder.append_non_negative_binary_integer(186, 9);
                encoder.append_bool(self.value.c187);
            }

            a_rust_source_q_choice_c188_e => {
                encoder.append_non_negative_binary_integer(187, 9);
                encoder.append_bool(self.value.c188);
            }

            a_rust_source_q_choice_c189_e => {
                encoder.append_non_negative_binary_integer(188, 9);
                encoder.append_bool(self.value.c189);
            }

            a_rust_source_q_choice_c190_e => {
                encoder.append_non_negative_binary_integer(189, 9);
                encoder.append_bool(self.value.c190);
            }

            a_rust_source_q_choice_c191_e => {
                encoder.append_non_negative_binary_integer(190, 9);
                encoder.append_bool(self.value.c191);
            }

            a_rust_source_q_choice_c192_e => {
                encoder.append_non_negative_binary_integer(191, 9);
                encoder.append_bool(self.value.c192);
            }

            a_rust_source_q_choice_c193_e => {
                encoder.append_non_negative_binary_integer(192, 9);
                encoder.append_bool(self.value.c193);
            }

            a_rust_source_q_choice_c194_e => {
                encoder.append_non_negative_binary_integer(193, 9);
                encoder.append_bool(self.value.c194);
            }

            a_rust_source_q_choice_c195_e => {
                encoder.append_non_negative_binary_integer(194, 9);
                encoder.append_bool(self.value.c195);
            }

            a_rust_source_q_choice_c196_e => {
                encoder.append_non_negative_binary_integer(195, 9);
                encoder.append_bool(self.value.c196);
            }

            a_rust_source_q_choice_c197_e => {
                encoder.append_non_negative_binary_integer(196, 9);
                encoder.append_bool(self.value.c197);
            }

            a_rust_source_q_choice_c198_e => {
                encoder.append_non_negative_binary_integer(197, 9);
                encoder.append_bool(self.value.c198);
            }

            a_rust_source_q_choice_c199_e => {
                encoder.append_non_negative_binary_integer(198, 9);
                encoder.append_bool(self.value.c199);
            }

            a_rust_source_q_choice_c200_e => {
                encoder.append_non_negative_binary_integer(199, 9);
                encoder.append_bool(self.value.c200);
            }

            a_rust_source_q_choice_c201_e => {
                encoder.append_non_negative_binary_integer(200, 9);
                encoder.append_bool(self.value.c201);
            }

            a_rust_source_q_choice_c202_e => {
                encoder.append_non_negative_binary_integer(201, 9);
                encoder.append_bool(self.value.c202);
            }

            a_rust_source_q_choice_c203_e => {
                encoder.append_non_negative_binary_integer(202, 9);
                encoder.append_bool(self.value.c203);
            }

            a_rust_source_q_choice_c204_e => {
                encoder.append_non_negative_binary_integer(203, 9);
                encoder.append_bool(self.value.c204);
            }

            a_rust_source_q_choice_c205_e => {
                encoder.append_non_negative_binary_integer(204, 9);
                encoder.append_bool(self.value.c205);
            }

            a_rust_source_q_choice_c206_e => {
                encoder.append_non_negative_binary_integer(205, 9);
                encoder.append_bool(self.value.c206);
            }

            a_rust_source_q_choice_c207_e => {
                encoder.append_non_negative_binary_integer(206, 9);
                encoder.append_bool(self.value.c207);
            }

            a_rust_source_q_choice_c208_e => {
                encoder.append_non_negative_binary_integer(207, 9);
                encoder.append_bool(self.value.c208);
            }

            a_rust_source_q_choice_c209_e => {
                encoder.append_non_negative_binary_integer(208, 9);
                encoder.append_bool(self.value.c209);
            }

            a_rust_source_q_choice_c210_e => {
                encoder.append_non_negative_binary_integer(209, 9);
                encoder.append_bool(self.value.c210);
            }

            a_rust_source_q_choice_c211_e => {
                encoder.append_non_negative_binary_integer(210, 9);
                encoder.append_bool(self.value.c211);
            }

            a_rust_source_q_choice_c212_e => {
                encoder.append_non_negative_binary_integer(211, 9);
                encoder.append_bool(self.value.c212);
            }

            a_rust_source_q_choice_c213_e => {
                encoder.append_non_negative_binary_integer(212, 9);
                encoder.append_bool(self.value.c213);
            }

            a_rust_source_q_choice_c214_e => {
                encoder.append_non_negative_binary_integer(213, 9);
                encoder.append_bool(self.value.c214);
            }

            a_rust_source_q_choice_c215_e => {
                encoder.append_non_negative_binary_integer(214, 9);
                encoder.append_bool(self.value.c215);
            }

            a_rust_source_q_choice_c216_e => {
                encoder.append_non_negative_binary_integer(215, 9);
                encoder.append_bool(self.value.c216);
            }

            a_rust_source_q_choice_c217_e => {
                encoder.append_non_negative_binary_integer(216, 9);
                encoder.append_bool(self.value.c217);
            }

            a_rust_source_q_choice_c218_e => {
                encoder.append_non_negative_binary_integer(217, 9);
                encoder.append_bool(self.value.c218);
            }

            a_rust_source_q_choice_c219_e => {
                encoder.append_non_negative_binary_integer(218, 9);
                encoder.append_bool(self.value.c219);
            }

            a_rust_source_q_choice_c220_e => {
                encoder.append_non_negative_binary_integer(219, 9);
                encoder.append_bool(self.value.c220);
            }

            a_rust_source_q_choice_c221_e => {
                encoder.append_non_negative_binary_integer(220, 9);
                encoder.append_bool(self.value.c221);
            }

            a_rust_source_q_choice_c222_e => {
                encoder.append_non_negative_binary_integer(221, 9);
                encoder.append_bool(self.value.c222);
            }

            a_rust_source_q_choice_c223_e => {
                encoder.append_non_negative_binary_integer(222, 9);
                encoder.append_bool(self.value.c223);
            }

            a_rust_source_q_choice_c224_e => {
                encoder.append_non_negative_binary_integer(223, 9);
                encoder.append_bool(self.value.c224);
            }

            a_rust_source_q_choice_c225_e => {
                encoder.append_non_negative_binary_integer(224, 9);
                encoder.append_bool(self.value.c225);
            }

            a_rust_source_q_choice_c226_e => {
                encoder.append_non_negative_binary_integer(225, 9);
                encoder.append_bool(self.value.c226);
            }

            a_rust_source_q_choice_c227_e => {
                encoder.append_non_negative_binary_integer(226, 9);
                encoder.append_bool(self.value.c227);
            }

            a_rust_source_q_choice_c228_e => {
                encoder.append_non_negative_binary_integer(227, 9);
                encoder.append_bool(self.value.c228);
            }

            a_rust_source_q_choice_c229_e => {
                encoder.append_non_negative_binary_integer(228, 9);
                encoder.append_bool(self.value.c229);
            }

            a_rust_source_q_choice_c230_e => {
                encoder.append_non_negative_binary_integer(229, 9);
                encoder.append_bool(self.value.c230);
            }

            a_rust_source_q_choice_c231_e => {
                encoder.append_non_negative_binary_integer(230, 9);
                encoder.append_bool(self.value.c231);
            }

            a_rust_source_q_choice_c232_e => {
                encoder.append_non_negative_binary_integer(231, 9);
                encoder.append_bool(self.value.c232);
            }

            a_rust_source_q_choice_c233_e => {
                encoder.append_non_negative_binary_integer(232, 9);
                encoder.append_bool(self.value.c233);
            }

            a_rust_source_q_choice_c234_e => {
                encoder.append_non_negative_binary_integer(233, 9);
                encoder.append_bool(self.value.c234);
            }

            a_rust_source_q_choice_c235_e => {
                encoder.append_non_negative_binary_integer(234, 9);
                encoder.append_bool(self.value.c235);
            }

            a_rust_source_q_choice_c236_e => {
                encoder.append_non_negative_binary_integer(235, 9);
                encoder.append_bool(self.value.c236);
            }

            a_rust_source_q_choice_c237_e => {
                encoder.append_non_negative_binary_integer(236, 9);
                encoder.append_bool(self.value.c237);
            }

            a_rust_source_q_choice_c238_e => {
                encoder.append_non_negative_binary_integer(237, 9);
                encoder.append_bool(self.value.c238);
            }

            a_rust_source_q_choice_c239_e => {
                encoder.append_non_negative_binary_integer(238, 9);
                encoder.append_bool(self.value.c239);
            }

            a_rust_source_q_choice_c240_e => {
                encoder.append_non_negative_binary_integer(239, 9);
                encoder.append_bool(self.value.c240);
            }

            a_rust_source_q_choice_c241_e => {
                encoder.append_non_negative_binary_integer(240, 9);
                encoder.append_bool(self.value.c241);
            }

            a_rust_source_q_choice_c242_e => {
                encoder.append_non_negative_binary_integer(241, 9);
                encoder.append_bool(self.value.c242);
            }

            a_rust_source_q_choice_c243_e => {
                encoder.append_non_negative_binary_integer(242, 9);
                encoder.append_bool(self.value.c243);
            }

            a_rust_source_q_choice_c244_e => {
                encoder.append_non_negative_binary_integer(243, 9);
                encoder.append_bool(self.value.c244);
            }

            a_rust_source_q_choice_c245_e => {
                encoder.append_non_negative_binary_integer(244, 9);
                encoder.append_bool(self.value.c245);
            }

            a_rust_source_q_choice_c246_e => {
                encoder.append_non_negative_binary_integer(245, 9);
                encoder.append_bool(self.value.c246);
            }

            a_rust_source_q_choice_c247_e => {
                encoder.append_non_negative_binary_integer(246, 9);
                encoder.append_bool(self.value.c247);
            }

            a_rust_source_q_choice_c248_e => {
                encoder.append_non_negative_binary_integer(247, 9);
                encoder.append_bool(self.value.c248);
            }

            a_rust_source_q_choice_c249_e => {
                encoder.append_non_negative_binary_integer(248, 9);
                encoder.append_bool(self.value.c249);
            }

            a_rust_source_q_choice_c250_e => {
                encoder.append_non_negative_binary_integer(249, 9);
                encoder.append_bool(self.value.c250);
            }

            a_rust_source_q_choice_c251_e => {
                encoder.append_non_negative_binary_integer(250, 9);
                encoder.append_bool(self.value.c251);
            }

            a_rust_source_q_choice_c252_e => {
                encoder.append_non_negative_binary_integer(251, 9);
                encoder.append_bool(self.value.c252);
            }

            a_rust_source_q_choice_c253_e => {
                encoder.append_non_negative_binary_integer(252, 9);
                encoder.append_bool(self.value.c253);
            }

            a_rust_source_q_choice_c254_e => {
                encoder.append_non_negative_binary_integer(253, 9);
                encoder.append_bool(self.value.c254);
            }

            a_rust_source_q_choice_c255_e => {
                encoder.append_non_negative_binary_integer(254, 9);
                encoder.append_bool(self.value.c255);
            }

            a_rust_source_q_choice_c256_e => {
                encoder.append_non_negative_binary_integer(255, 9);
                encoder.append_bool(self.value.c256);
            }

            a_rust_source_q_choice_c257_e => {
                encoder.append_non_negative_binary_integer(256, 9);
                encoder.append_bool(self.value.c257);
            }

            _ => encoder.abort(EBADCHOICE);
        }
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        u16 choice;

        choice = decoder.read_non_negative_binary_integer(9);

        match choice {

            0 => {
                self.choice = a_rust_source_q_choice_c001_e;
                self.value.c001 = decoder.read_bool();
            }

            1 => {
                self.choice = a_rust_source_q_choice_c002_e;
                self.value.c002 = decoder.read_bool();
            }

            2 => {
                self.choice = a_rust_source_q_choice_c003_e;
                self.value.c003 = decoder.read_bool();
            }

            3 => {
                self.choice = a_rust_source_q_choice_c004_e;
                self.value.c004 = decoder.read_bool();
            }

            4 => {
                self.choice = a_rust_source_q_choice_c005_e;
                self.value.c005 = decoder.read_bool();
            }

            5 => {
                self.choice = a_rust_source_q_choice_c006_e;
                self.value.c006 = decoder.read_bool();
            }

            6 => {
                self.choice = a_rust_source_q_choice_c007_e;
                self.value.c007 = decoder.read_bool();
            }

            7 => {
                self.choice = a_rust_source_q_choice_c008_e;
                self.value.c008 = decoder.read_bool();
            }

            8 => {
                self.choice = a_rust_source_q_choice_c009_e;
                self.value.c009 = decoder.read_bool();
            }

            9 => {
                self.choice = a_rust_source_q_choice_c010_e;
                self.value.c010 = decoder.read_bool();
            }

            10 => {
                self.choice = a_rust_source_q_choice_c011_e;
                self.value.c011 = decoder.read_bool();
            }

            11 => {
                self.choice = a_rust_source_q_choice_c012_e;
                self.value.c012 = decoder.read_bool();
            }

            12 => {
                self.choice = a_rust_source_q_choice_c013_e;
                self.value.c013 = decoder.read_bool();
            }

            13 => {
                self.choice = a_rust_source_q_choice_c014_e;
                self.value.c014 = decoder.read_bool();
            }

            14 => {
                self.choice = a_rust_source_q_choice_c015_e;
                self.value.c015 = decoder.read_bool();
            }

            15 => {
                self.choice = a_rust_source_q_choice_c016_e;
                self.value.c016 = decoder.read_bool();
            }

            16 => {
                self.choice = a_rust_source_q_choice_c017_e;
                self.value.c017 = decoder.read_bool();
            }

            17 => {
                self.choice = a_rust_source_q_choice_c018_e;
                self.value.c018 = decoder.read_bool();
            }

            18 => {
                self.choice = a_rust_source_q_choice_c019_e;
                self.value.c019 = decoder.read_bool();
            }

            19 => {
                self.choice = a_rust_source_q_choice_c020_e;
                self.value.c020 = decoder.read_bool();
            }

            20 => {
                self.choice = a_rust_source_q_choice_c021_e;
                self.value.c021 = decoder.read_bool();
            }

            21 => {
                self.choice = a_rust_source_q_choice_c022_e;
                self.value.c022 = decoder.read_bool();
            }

            22 => {
                self.choice = a_rust_source_q_choice_c023_e;
                self.value.c023 = decoder.read_bool();
            }

            23 => {
                self.choice = a_rust_source_q_choice_c024_e;
                self.value.c024 = decoder.read_bool();
            }

            24 => {
                self.choice = a_rust_source_q_choice_c025_e;
                self.value.c025 = decoder.read_bool();
            }

            25 => {
                self.choice = a_rust_source_q_choice_c026_e;
                self.value.c026 = decoder.read_bool();
            }

            26 => {
                self.choice = a_rust_source_q_choice_c027_e;
                self.value.c027 = decoder.read_bool();
            }

            27 => {
                self.choice = a_rust_source_q_choice_c028_e;
                self.value.c028 = decoder.read_bool();
            }

            28 => {
                self.choice = a_rust_source_q_choice_c029_e;
                self.value.c029 = decoder.read_bool();
            }

            29 => {
                self.choice = a_rust_source_q_choice_c030_e;
                self.value.c030 = decoder.read_bool();
            }

            30 => {
                self.choice = a_rust_source_q_choice_c031_e;
                self.value.c031 = decoder.read_bool();
            }

            31 => {
                self.choice = a_rust_source_q_choice_c032_e;
                self.value.c032 = decoder.read_bool();
            }

            32 => {
                self.choice = a_rust_source_q_choice_c033_e;
                self.value.c033 = decoder.read_bool();
            }

            33 => {
                self.choice = a_rust_source_q_choice_c034_e;
                self.value.c034 = decoder.read_bool();
            }

            34 => {
                self.choice = a_rust_source_q_choice_c035_e;
                self.value.c035 = decoder.read_bool();
            }

            35 => {
                self.choice = a_rust_source_q_choice_c036_e;
                self.value.c036 = decoder.read_bool();
            }

            36 => {
                self.choice = a_rust_source_q_choice_c037_e;
                self.value.c037 = decoder.read_bool();
            }

            37 => {
                self.choice = a_rust_source_q_choice_c038_e;
                self.value.c038 = decoder.read_bool();
            }

            38 => {
                self.choice = a_rust_source_q_choice_c039_e;
                self.value.c039 = decoder.read_bool();
            }

            39 => {
                self.choice = a_rust_source_q_choice_c040_e;
                self.value.c040 = decoder.read_bool();
            }

            40 => {
                self.choice = a_rust_source_q_choice_c041_e;
                self.value.c041 = decoder.read_bool();
            }

            41 => {
                self.choice = a_rust_source_q_choice_c042_e;
                self.value.c042 = decoder.read_bool();
            }

            42 => {
                self.choice = a_rust_source_q_choice_c043_e;
                self.value.c043 = decoder.read_bool();
            }

            43 => {
                self.choice = a_rust_source_q_choice_c044_e;
                self.value.c044 = decoder.read_bool();
            }

            44 => {
                self.choice = a_rust_source_q_choice_c045_e;
                self.value.c045 = decoder.read_bool();
            }

            45 => {
                self.choice = a_rust_source_q_choice_c046_e;
                self.value.c046 = decoder.read_bool();
            }

            46 => {
                self.choice = a_rust_source_q_choice_c047_e;
                self.value.c047 = decoder.read_bool();
            }

            47 => {
                self.choice = a_rust_source_q_choice_c048_e;
                self.value.c048 = decoder.read_bool();
            }

            48 => {
                self.choice = a_rust_source_q_choice_c049_e;
                self.value.c049 = decoder.read_bool();
            }

            49 => {
                self.choice = a_rust_source_q_choice_c050_e;
                self.value.c050 = decoder.read_bool();
            }

            50 => {
                self.choice = a_rust_source_q_choice_c051_e;
                self.value.c051 = decoder.read_bool();
            }

            51 => {
                self.choice = a_rust_source_q_choice_c052_e;
                self.value.c052 = decoder.read_bool();
            }

            52 => {
                self.choice = a_rust_source_q_choice_c053_e;
                self.value.c053 = decoder.read_bool();
            }

            53 => {
                self.choice = a_rust_source_q_choice_c054_e;
                self.value.c054 = decoder.read_bool();
            }

            54 => {
                self.choice = a_rust_source_q_choice_c055_e;
                self.value.c055 = decoder.read_bool();
            }

            55 => {
                self.choice = a_rust_source_q_choice_c056_e;
                self.value.c056 = decoder.read_bool();
            }

            56 => {
                self.choice = a_rust_source_q_choice_c057_e;
                self.value.c057 = decoder.read_bool();
            }

            57 => {
                self.choice = a_rust_source_q_choice_c058_e;
                self.value.c058 = decoder.read_bool();
            }

            58 => {
                self.choice = a_rust_source_q_choice_c059_e;
                self.value.c059 = decoder.read_bool();
            }

            59 => {
                self.choice = a_rust_source_q_choice_c060_e;
                self.value.c060 = decoder.read_bool();
            }

            60 => {
                self.choice = a_rust_source_q_choice_c061_e;
                self.value.c061 = decoder.read_bool();
            }

            61 => {
                self.choice = a_rust_source_q_choice_c062_e;
                self.value.c062 = decoder.read_bool();
            }

            62 => {
                self.choice = a_rust_source_q_choice_c063_e;
                self.value.c063 = decoder.read_bool();
            }

            63 => {
                self.choice = a_rust_source_q_choice_c064_e;
                self.value.c064 = decoder.read_bool();
            }

            64 => {
                self.choice = a_rust_source_q_choice_c065_e;
                self.value.c065 = decoder.read_bool();
            }

            65 => {
                self.choice = a_rust_source_q_choice_c066_e;
                self.value.c066 = decoder.read_bool();
            }

            66 => {
                self.choice = a_rust_source_q_choice_c067_e;
                self.value.c067 = decoder.read_bool();
            }

            67 => {
                self.choice = a_rust_source_q_choice_c068_e;
                self.value.c068 = decoder.read_bool();
            }

            68 => {
                self.choice = a_rust_source_q_choice_c069_e;
                self.value.c069 = decoder.read_bool();
            }

            69 => {
                self.choice = a_rust_source_q_choice_c070_e;
                self.value.c070 = decoder.read_bool();
            }

            70 => {
                self.choice = a_rust_source_q_choice_c071_e;
                self.value.c071 = decoder.read_bool();
            }

            71 => {
                self.choice = a_rust_source_q_choice_c072_e;
                self.value.c072 = decoder.read_bool();
            }

            72 => {
                self.choice = a_rust_source_q_choice_c073_e;
                self.value.c073 = decoder.read_bool();
            }

            73 => {
                self.choice = a_rust_source_q_choice_c074_e;
                self.value.c074 = decoder.read_bool();
            }

            74 => {
                self.choice = a_rust_source_q_choice_c075_e;
                self.value.c075 = decoder.read_bool();
            }

            75 => {
                self.choice = a_rust_source_q_choice_c076_e;
                self.value.c076 = decoder.read_bool();
            }

            76 => {
                self.choice = a_rust_source_q_choice_c077_e;
                self.value.c077 = decoder.read_bool();
            }

            77 => {
                self.choice = a_rust_source_q_choice_c078_e;
                self.value.c078 = decoder.read_bool();
            }

            78 => {
                self.choice = a_rust_source_q_choice_c079_e;
                self.value.c079 = decoder.read_bool();
            }

            79 => {
                self.choice = a_rust_source_q_choice_c080_e;
                self.value.c080 = decoder.read_bool();
            }

            80 => {
                self.choice = a_rust_source_q_choice_c081_e;
                self.value.c081 = decoder.read_bool();
            }

            81 => {
                self.choice = a_rust_source_q_choice_c082_e;
                self.value.c082 = decoder.read_bool();
            }

            82 => {
                self.choice = a_rust_source_q_choice_c083_e;
                self.value.c083 = decoder.read_bool();
            }

            83 => {
                self.choice = a_rust_source_q_choice_c084_e;
                self.value.c084 = decoder.read_bool();
            }

            84 => {
                self.choice = a_rust_source_q_choice_c085_e;
                self.value.c085 = decoder.read_bool();
            }

            85 => {
                self.choice = a_rust_source_q_choice_c086_e;
                self.value.c086 = decoder.read_bool();
            }

            86 => {
                self.choice = a_rust_source_q_choice_c087_e;
                self.value.c087 = decoder.read_bool();
            }

            87 => {
                self.choice = a_rust_source_q_choice_c088_e;
                self.value.c088 = decoder.read_bool();
            }

            88 => {
                self.choice = a_rust_source_q_choice_c089_e;
                self.value.c089 = decoder.read_bool();
            }

            89 => {
                self.choice = a_rust_source_q_choice_c090_e;
                self.value.c090 = decoder.read_bool();
            }

            90 => {
                self.choice = a_rust_source_q_choice_c091_e;
                self.value.c091 = decoder.read_bool();
            }

            91 => {
                self.choice = a_rust_source_q_choice_c092_e;
                self.value.c092 = decoder.read_bool();
            }

            92 => {
                self.choice = a_rust_source_q_choice_c093_e;
                self.value.c093 = decoder.read_bool();
            }

            93 => {
                self.choice = a_rust_source_q_choice_c094_e;
                self.value.c094 = decoder.read_bool();
            }

            94 => {
                self.choice = a_rust_source_q_choice_c095_e;
                self.value.c095 = decoder.read_bool();
            }

            95 => {
                self.choice = a_rust_source_q_choice_c096_e;
                self.value.c096 = decoder.read_bool();
            }

            96 => {
                self.choice = a_rust_source_q_choice_c097_e;
                self.value.c097 = decoder.read_bool();
            }

            97 => {
                self.choice = a_rust_source_q_choice_c098_e;
                self.value.c098 = decoder.read_bool();
            }

            98 => {
                self.choice = a_rust_source_q_choice_c099_e;
                self.value.c099 = decoder.read_bool();
            }

            99 => {
                self.choice = a_rust_source_q_choice_c100_e;
                self.value.c100 = decoder.read_bool();
            }

            100 => {
                self.choice = a_rust_source_q_choice_c101_e;
                self.value.c101 = decoder.read_bool();
            }

            101 => {
                self.choice = a_rust_source_q_choice_c102_e;
                self.value.c102 = decoder.read_bool();
            }

            102 => {
                self.choice = a_rust_source_q_choice_c103_e;
                self.value.c103 = decoder.read_bool();
            }

            103 => {
                self.choice = a_rust_source_q_choice_c104_e;
                self.value.c104 = decoder.read_bool();
            }

            104 => {
                self.choice = a_rust_source_q_choice_c105_e;
                self.value.c105 = decoder.read_bool();
            }

            105 => {
                self.choice = a_rust_source_q_choice_c106_e;
                self.value.c106 = decoder.read_bool();
            }

            106 => {
                self.choice = a_rust_source_q_choice_c107_e;
                self.value.c107 = decoder.read_bool();
            }

            107 => {
                self.choice = a_rust_source_q_choice_c108_e;
                self.value.c108 = decoder.read_bool();
            }

            108 => {
                self.choice = a_rust_source_q_choice_c109_e;
                self.value.c109 = decoder.read_bool();
            }

            109 => {
                self.choice = a_rust_source_q_choice_c110_e;
                self.value.c110 = decoder.read_bool();
            }

            110 => {
                self.choice = a_rust_source_q_choice_c111_e;
                self.value.c111 = decoder.read_bool();
            }

            111 => {
                self.choice = a_rust_source_q_choice_c112_e;
                self.value.c112 = decoder.read_bool();
            }

            112 => {
                self.choice = a_rust_source_q_choice_c113_e;
                self.value.c113 = decoder.read_bool();
            }

            113 => {
                self.choice = a_rust_source_q_choice_c114_e;
                self.value.c114 = decoder.read_bool();
            }

            114 => {
                self.choice = a_rust_source_q_choice_c115_e;
                self.value.c115 = decoder.read_bool();
            }

            115 => {
                self.choice = a_rust_source_q_choice_c116_e;
                self.value.c116 = decoder.read_bool();
            }

            116 => {
                self.choice = a_rust_source_q_choice_c117_e;
                self.value.c117 = decoder.read_bool();
            }

            117 => {
                self.choice = a_rust_source_q_choice_c118_e;
                self.value.c118 = decoder.read_bool();
            }

            118 => {
                self.choice = a_rust_source_q_choice_c119_e;
                self.value.c119 = decoder.read_bool();
            }

            119 => {
                self.choice = a_rust_source_q_choice_c120_e;
                self.value.c120 = decoder.read_bool();
            }

            120 => {
                self.choice = a_rust_source_q_choice_c121_e;
                self.value.c121 = decoder.read_bool();
            }

            121 => {
                self.choice = a_rust_source_q_choice_c122_e;
                self.value.c122 = decoder.read_bool();
            }

            122 => {
                self.choice = a_rust_source_q_choice_c123_e;
                self.value.c123 = decoder.read_bool();
            }

            123 => {
                self.choice = a_rust_source_q_choice_c124_e;
                self.value.c124 = decoder.read_bool();
            }

            124 => {
                self.choice = a_rust_source_q_choice_c125_e;
                self.value.c125 = decoder.read_bool();
            }

            125 => {
                self.choice = a_rust_source_q_choice_c126_e;
                self.value.c126 = decoder.read_bool();
            }

            126 => {
                self.choice = a_rust_source_q_choice_c127_e;
                self.value.c127 = decoder.read_bool();
            }

            127 => {
                self.choice = a_rust_source_q_choice_c128_e;
                self.value.c128 = decoder.read_bool();
            }

            128 => {
                self.choice = a_rust_source_q_choice_c129_e;
                self.value.c129 = decoder.read_bool();
            }

            129 => {
                self.choice = a_rust_source_q_choice_c130_e;
                self.value.c130 = decoder.read_bool();
            }

            130 => {
                self.choice = a_rust_source_q_choice_c131_e;
                self.value.c131 = decoder.read_bool();
            }

            131 => {
                self.choice = a_rust_source_q_choice_c132_e;
                self.value.c132 = decoder.read_bool();
            }

            132 => {
                self.choice = a_rust_source_q_choice_c133_e;
                self.value.c133 = decoder.read_bool();
            }

            133 => {
                self.choice = a_rust_source_q_choice_c134_e;
                self.value.c134 = decoder.read_bool();
            }

            134 => {
                self.choice = a_rust_source_q_choice_c135_e;
                self.value.c135 = decoder.read_bool();
            }

            135 => {
                self.choice = a_rust_source_q_choice_c136_e;
                self.value.c136 = decoder.read_bool();
            }

            136 => {
                self.choice = a_rust_source_q_choice_c137_e;
                self.value.c137 = decoder.read_bool();
            }

            137 => {
                self.choice = a_rust_source_q_choice_c138_e;
                self.value.c138 = decoder.read_bool();
            }

            138 => {
                self.choice = a_rust_source_q_choice_c139_e;
                self.value.c139 = decoder.read_bool();
            }

            139 => {
                self.choice = a_rust_source_q_choice_c140_e;
                self.value.c140 = decoder.read_bool();
            }

            140 => {
                self.choice = a_rust_source_q_choice_c141_e;
                self.value.c141 = decoder.read_bool();
            }

            141 => {
                self.choice = a_rust_source_q_choice_c142_e;
                self.value.c142 = decoder.read_bool();
            }

            142 => {
                self.choice = a_rust_source_q_choice_c143_e;
                self.value.c143 = decoder.read_bool();
            }

            143 => {
                self.choice = a_rust_source_q_choice_c144_e;
                self.value.c144 = decoder.read_bool();
            }

            144 => {
                self.choice = a_rust_source_q_choice_c145_e;
                self.value.c145 = decoder.read_bool();
            }

            145 => {
                self.choice = a_rust_source_q_choice_c146_e;
                self.value.c146 = decoder.read_bool();
            }

            146 => {
                self.choice = a_rust_source_q_choice_c147_e;
                self.value.c147 = decoder.read_bool();
            }

            147 => {
                self.choice = a_rust_source_q_choice_c148_e;
                self.value.c148 = decoder.read_bool();
            }

            148 => {
                self.choice = a_rust_source_q_choice_c149_e;
                self.value.c149 = decoder.read_bool();
            }

            149 => {
                self.choice = a_rust_source_q_choice_c150_e;
                self.value.c150 = decoder.read_bool();
            }

            150 => {
                self.choice = a_rust_source_q_choice_c151_e;
                self.value.c151 = decoder.read_bool();
            }

            151 => {
                self.choice = a_rust_source_q_choice_c152_e;
                self.value.c152 = decoder.read_bool();
            }

            152 => {
                self.choice = a_rust_source_q_choice_c153_e;
                self.value.c153 = decoder.read_bool();
            }

            153 => {
                self.choice = a_rust_source_q_choice_c154_e;
                self.value.c154 = decoder.read_bool();
            }

            154 => {
                self.choice = a_rust_source_q_choice_c155_e;
                self.value.c155 = decoder.read_bool();
            }

            155 => {
                self.choice = a_rust_source_q_choice_c156_e;
                self.value.c156 = decoder.read_bool();
            }

            156 => {
                self.choice = a_rust_source_q_choice_c157_e;
                self.value.c157 = decoder.read_bool();
            }

            157 => {
                self.choice = a_rust_source_q_choice_c158_e;
                self.value.c158 = decoder.read_bool();
            }

            158 => {
                self.choice = a_rust_source_q_choice_c159_e;
                self.value.c159 = decoder.read_bool();
            }

            159 => {
                self.choice = a_rust_source_q_choice_c160_e;
                self.value.c160 = decoder.read_bool();
            }

            160 => {
                self.choice = a_rust_source_q_choice_c161_e;
                self.value.c161 = decoder.read_bool();
            }

            161 => {
                self.choice = a_rust_source_q_choice_c162_e;
                self.value.c162 = decoder.read_bool();
            }

            162 => {
                self.choice = a_rust_source_q_choice_c163_e;
                self.value.c163 = decoder.read_bool();
            }

            163 => {
                self.choice = a_rust_source_q_choice_c164_e;
                self.value.c164 = decoder.read_bool();
            }

            164 => {
                self.choice = a_rust_source_q_choice_c165_e;
                self.value.c165 = decoder.read_bool();
            }

            165 => {
                self.choice = a_rust_source_q_choice_c166_e;
                self.value.c166 = decoder.read_bool();
            }

            166 => {
                self.choice = a_rust_source_q_choice_c167_e;
                self.value.c167 = decoder.read_bool();
            }

            167 => {
                self.choice = a_rust_source_q_choice_c168_e;
                self.value.c168 = decoder.read_bool();
            }

            168 => {
                self.choice = a_rust_source_q_choice_c169_e;
                self.value.c169 = decoder.read_bool();
            }

            169 => {
                self.choice = a_rust_source_q_choice_c170_e;
                self.value.c170 = decoder.read_bool();
            }

            170 => {
                self.choice = a_rust_source_q_choice_c171_e;
                self.value.c171 = decoder.read_bool();
            }

            171 => {
                self.choice = a_rust_source_q_choice_c172_e;
                self.value.c172 = decoder.read_bool();
            }

            172 => {
                self.choice = a_rust_source_q_choice_c173_e;
                self.value.c173 = decoder.read_bool();
            }

            173 => {
                self.choice = a_rust_source_q_choice_c174_e;
                self.value.c174 = decoder.read_bool();
            }

            174 => {
                self.choice = a_rust_source_q_choice_c175_e;
                self.value.c175 = decoder.read_bool();
            }

            175 => {
                self.choice = a_rust_source_q_choice_c176_e;
                self.value.c176 = decoder.read_bool();
            }

            176 => {
                self.choice = a_rust_source_q_choice_c177_e;
                self.value.c177 = decoder.read_bool();
            }

            177 => {
                self.choice = a_rust_source_q_choice_c178_e;
                self.value.c178 = decoder.read_bool();
            }

            178 => {
                self.choice = a_rust_source_q_choice_c179_e;
                self.value.c179 = decoder.read_bool();
            }

            179 => {
                self.choice = a_rust_source_q_choice_c180_e;
                self.value.c180 = decoder.read_bool();
            }

            180 => {
                self.choice = a_rust_source_q_choice_c181_e;
                self.value.c181 = decoder.read_bool();
            }

            181 => {
                self.choice = a_rust_source_q_choice_c182_e;
                self.value.c182 = decoder.read_bool();
            }

            182 => {
                self.choice = a_rust_source_q_choice_c183_e;
                self.value.c183 = decoder.read_bool();
            }

            183 => {
                self.choice = a_rust_source_q_choice_c184_e;
                self.value.c184 = decoder.read_bool();
            }

            184 => {
                self.choice = a_rust_source_q_choice_c185_e;
                self.value.c185 = decoder.read_bool();
            }

            185 => {
                self.choice = a_rust_source_q_choice_c186_e;
                self.value.c186 = decoder.read_bool();
            }

            186 => {
                self.choice = a_rust_source_q_choice_c187_e;
                self.value.c187 = decoder.read_bool();
            }

            187 => {
                self.choice = a_rust_source_q_choice_c188_e;
                self.value.c188 = decoder.read_bool();
            }

            188 => {
                self.choice = a_rust_source_q_choice_c189_e;
                self.value.c189 = decoder.read_bool();
            }

            189 => {
                self.choice = a_rust_source_q_choice_c190_e;
                self.value.c190 = decoder.read_bool();
            }

            190 => {
                self.choice = a_rust_source_q_choice_c191_e;
                self.value.c191 = decoder.read_bool();
            }

            191 => {
                self.choice = a_rust_source_q_choice_c192_e;
                self.value.c192 = decoder.read_bool();
            }

            192 => {
                self.choice = a_rust_source_q_choice_c193_e;
                self.value.c193 = decoder.read_bool();
            }

            193 => {
                self.choice = a_rust_source_q_choice_c194_e;
                self.value.c194 = decoder.read_bool();
            }

            194 => {
                self.choice = a_rust_source_q_choice_c195_e;
                self.value.c195 = decoder.read_bool();
            }

            195 => {
                self.choice = a_rust_source_q_choice_c196_e;
                self.value.c196 = decoder.read_bool();
            }

            196 => {
                self.choice = a_rust_source_q_choice_c197_e;
                self.value.c197 = decoder.read_bool();
            }

            197 => {
                self.choice = a_rust_source_q_choice_c198_e;
                self.value.c198 = decoder.read_bool();
            }

            198 => {
                self.choice = a_rust_source_q_choice_c199_e;
                self.value.c199 = decoder.read_bool();
            }

            199 => {
                self.choice = a_rust_source_q_choice_c200_e;
                self.value.c200 = decoder.read_bool();
            }

            200 => {
                self.choice = a_rust_source_q_choice_c201_e;
                self.value.c201 = decoder.read_bool();
            }

            201 => {
                self.choice = a_rust_source_q_choice_c202_e;
                self.value.c202 = decoder.read_bool();
            }

            202 => {
                self.choice = a_rust_source_q_choice_c203_e;
                self.value.c203 = decoder.read_bool();
            }

            203 => {
                self.choice = a_rust_source_q_choice_c204_e;
                self.value.c204 = decoder.read_bool();
            }

            204 => {
                self.choice = a_rust_source_q_choice_c205_e;
                self.value.c205 = decoder.read_bool();
            }

            205 => {
                self.choice = a_rust_source_q_choice_c206_e;
                self.value.c206 = decoder.read_bool();
            }

            206 => {
                self.choice = a_rust_source_q_choice_c207_e;
                self.value.c207 = decoder.read_bool();
            }

            207 => {
                self.choice = a_rust_source_q_choice_c208_e;
                self.value.c208 = decoder.read_bool();
            }

            208 => {
                self.choice = a_rust_source_q_choice_c209_e;
                self.value.c209 = decoder.read_bool();
            }

            209 => {
                self.choice = a_rust_source_q_choice_c210_e;
                self.value.c210 = decoder.read_bool();
            }

            210 => {
                self.choice = a_rust_source_q_choice_c211_e;
                self.value.c211 = decoder.read_bool();
            }

            211 => {
                self.choice = a_rust_source_q_choice_c212_e;
                self.value.c212 = decoder.read_bool();
            }

            212 => {
                self.choice = a_rust_source_q_choice_c213_e;
                self.value.c213 = decoder.read_bool();
            }

            213 => {
                self.choice = a_rust_source_q_choice_c214_e;
                self.value.c214 = decoder.read_bool();
            }

            214 => {
                self.choice = a_rust_source_q_choice_c215_e;
                self.value.c215 = decoder.read_bool();
            }

            215 => {
                self.choice = a_rust_source_q_choice_c216_e;
                self.value.c216 = decoder.read_bool();
            }

            216 => {
                self.choice = a_rust_source_q_choice_c217_e;
                self.value.c217 = decoder.read_bool();
            }

            217 => {
                self.choice = a_rust_source_q_choice_c218_e;
                self.value.c218 = decoder.read_bool();
            }

            218 => {
                self.choice = a_rust_source_q_choice_c219_e;
                self.value.c219 = decoder.read_bool();
            }

            219 => {
                self.choice = a_rust_source_q_choice_c220_e;
                self.value.c220 = decoder.read_bool();
            }

            220 => {
                self.choice = a_rust_source_q_choice_c221_e;
                self.value.c221 = decoder.read_bool();
            }

            221 => {
                self.choice = a_rust_source_q_choice_c222_e;
                self.value.c222 = decoder.read_bool();
            }

            222 => {
                self.choice = a_rust_source_q_choice_c223_e;
                self.value.c223 = decoder.read_bool();
            }

            223 => {
                self.choice = a_rust_source_q_choice_c224_e;
                self.value.c224 = decoder.read_bool();
            }

            224 => {
                self.choice = a_rust_source_q_choice_c225_e;
                self.value.c225 = decoder.read_bool();
            }

            225 => {
                self.choice = a_rust_source_q_choice_c226_e;
                self.value.c226 = decoder.read_bool();
            }

            226 => {
                self.choice = a_rust_source_q_choice_c227_e;
                self.value.c227 = decoder.read_bool();
            }

            227 => {
                self.choice = a_rust_source_q_choice_c228_e;
                self.value.c228 = decoder.read_bool();
            }

            228 => {
                self.choice = a_rust_source_q_choice_c229_e;
                self.value.c229 = decoder.read_bool();
            }

            229 => {
                self.choice = a_rust_source_q_choice_c230_e;
                self.value.c230 = decoder.read_bool();
            }

            230 => {
                self.choice = a_rust_source_q_choice_c231_e;
                self.value.c231 = decoder.read_bool();
            }

            231 => {
                self.choice = a_rust_source_q_choice_c232_e;
                self.value.c232 = decoder.read_bool();
            }

            232 => {
                self.choice = a_rust_source_q_choice_c233_e;
                self.value.c233 = decoder.read_bool();
            }

            233 => {
                self.choice = a_rust_source_q_choice_c234_e;
                self.value.c234 = decoder.read_bool();
            }

            234 => {
                self.choice = a_rust_source_q_choice_c235_e;
                self.value.c235 = decoder.read_bool();
            }

            235 => {
                self.choice = a_rust_source_q_choice_c236_e;
                self.value.c236 = decoder.read_bool();
            }

            236 => {
                self.choice = a_rust_source_q_choice_c237_e;
                self.value.c237 = decoder.read_bool();
            }

            237 => {
                self.choice = a_rust_source_q_choice_c238_e;
                self.value.c238 = decoder.read_bool();
            }

            238 => {
                self.choice = a_rust_source_q_choice_c239_e;
                self.value.c239 = decoder.read_bool();
            }

            239 => {
                self.choice = a_rust_source_q_choice_c240_e;
                self.value.c240 = decoder.read_bool();
            }

            240 => {
                self.choice = a_rust_source_q_choice_c241_e;
                self.value.c241 = decoder.read_bool();
            }

            241 => {
                self.choice = a_rust_source_q_choice_c242_e;
                self.value.c242 = decoder.read_bool();
            }

            242 => {
                self.choice = a_rust_source_q_choice_c243_e;
                self.value.c243 = decoder.read_bool();
            }

            243 => {
                self.choice = a_rust_source_q_choice_c244_e;
                self.value.c244 = decoder.read_bool();
            }

            244 => {
                self.choice = a_rust_source_q_choice_c245_e;
                self.value.c245 = decoder.read_bool();
            }

            245 => {
                self.choice = a_rust_source_q_choice_c246_e;
                self.value.c246 = decoder.read_bool();
            }

            246 => {
                self.choice = a_rust_source_q_choice_c247_e;
                self.value.c247 = decoder.read_bool();
            }

            247 => {
                self.choice = a_rust_source_q_choice_c248_e;
                self.value.c248 = decoder.read_bool();
            }

            248 => {
                self.choice = a_rust_source_q_choice_c249_e;
                self.value.c249 = decoder.read_bool();
            }

            249 => {
                self.choice = a_rust_source_q_choice_c250_e;
                self.value.c250 = decoder.read_bool();
            }

            250 => {
                self.choice = a_rust_source_q_choice_c251_e;
                self.value.c251 = decoder.read_bool();
            }

            251 => {
                self.choice = a_rust_source_q_choice_c252_e;
                self.value.c252 = decoder.read_bool();
            }

            252 => {
                self.choice = a_rust_source_q_choice_c253_e;
                self.value.c253 = decoder.read_bool();
            }

            253 => {
                self.choice = a_rust_source_q_choice_c254_e;
                self.value.c254 = decoder.read_bool();
            }

            254 => {
                self.choice = a_rust_source_q_choice_c255_e;
                self.value.c255 = decoder.read_bool();
            }

            255 => {
                self.choice = a_rust_source_q_choice_c256_e;
                self.value.c256 = decoder.read_bool();
            }

            256 => {
                self.choice = a_rust_source_q_choice_c257_e;
                self.value.c257 = decoder.read_bool();
            }

            _ => decoder.abort(EBADCHOICE);
        }
    }
}

impl RustSourceAC {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        self.a.to_bytes_inner(&mut encoder);
        self.b.to_bytes_inner(&mut encoder);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.a.from_bytes_inner(&mut decoder);
        self.b.from_bytes_inner(&mut decoder);
    }
}

impl RustSourceB {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        match self.choice {

            a_rust_source_b_choice_a_e => {
                encoder.append_non_negative_binary_integer(0, 2);
                encoder.append_i8(self.value.a);
            }

            a_rust_source_b_choice_b_e => {
                encoder.append_non_negative_binary_integer(1, 2);
                self.value.b.to_bytes_inner(&mut encoder);
            }

            a_rust_source_b_choice_c_e => {
                encoder.append_non_negative_binary_integer(2, 2);
            }

            _ => encoder.abort(EBADCHOICE);
        }
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        u8 choice;

        choice = decoder.read_non_negative_binary_integer(2);

        match choice {

            0 => {
                self.choice = a_rust_source_b_choice_a_e;
                self.value.a = decoder.read_i8();
            }

            1 => {
                self.choice = a_rust_source_b_choice_b_e;
                self.value.b.from_bytes_inner(&mut decoder);
            }

            2 => {
                self.choice = a_rust_source_b_choice_c_e;
            }

            _ => decoder.abort(EBADCHOICE);
        }
    }
}

impl RustSourceC {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        u8 i;

        encoder.append_non_negative_binary_integer(
            self.length - 0u,
            2);

        for i in 0..self.length {
            self.elements[i].to_bytes_inner(&mut encoder);
        }
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        u8 i;

        self.length = decoder.read_non_negative_binary_integer(2);
        self.length += 0;

        if self.length > 2 {
            decoder.abort(EBADLENGTH);

            return;
        }

        for i in 0..self.length {
            self.elements[i].from_bytes_inner(&mut decoder);
        }
    }
}

impl RustSourceE {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        match self.a.choice {

            a_rust_source_e_a_choice_b_e => {
                encoder.append_non_negative_binary_integer(0, 0);

                match self.a.value.b.choice {

                    a_rust_source_e_a_b_choice_c_e => {
                        encoder.append_non_negative_binary_integer(0, 0);
                        encoder.append_bool(self.a.value.b.value.c);
                    }

                    _ => encoder.abort(EBADCHOICE);
                }
            }

            _ => encoder.abort(EBADCHOICE);
        }
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        u8 choice;
        u8 choice_2;

        choice = decoder.read_non_negative_binary_integer(0);

        match choice {

            0 => {
                self.a.choice = a_rust_source_e_a_choice_b_e;
                choice_2 = decoder.read_non_negative_binary_integer(0);

                match choice_2 {

                    0 => {
                        self.a.value.b.choice = a_rust_source_e_a_b_choice_c_e;
                        self.a.value.b.value.c = decoder.read_bool();
                    }

                    _ => decoder.abort(EBADCHOICE);
                }
            }

            _ => decoder.abort(EBADCHOICE);
        }
    }
}

impl RustSourceF {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        u8 i;
        u8 i_2;

        encoder.append_non_negative_binary_integer(
            self.length - 1u,
            1);

        for i in 0..self.length {
            for i_2 in 0..1 {
                encoder.append_bool(self.elements[i].elements[i_2]);
            }
        }
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        u8 i;
        u8 i_2;

        self.length = decoder.read_non_negative_binary_integer(1);
        self.length += 1;

        for i in 0..self.length {
            for i_2 in 0..1 {
                self.elements[i].elements[i_2] = decoder.read_bool();
            }
        }
    }
}

impl RustSourceG {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_bit(self.is_a_present as u8);
        encoder.append_bit(self.is_b_present as u8);
        encoder.append_bit(self.is_c_present as u8);
        encoder.append_bit(self.is_d_present as u8);
        encoder.append_bit(self.is_e_present as u8);
        encoder.append_bit(self.is_f_present as u8);
        encoder.append_bit(self.is_g_present as u8);
        encoder.append_bit(self.is_h_present as u8);
        encoder.append_bit(self.is_i_present as u8);

        if src.is_a_present {
            encoder.append_bool(self.a);
        }

        if src.is_b_present {
            encoder.append_bool(self.b);
        }

        if src.is_c_present {
            encoder.append_bool(self.c);
        }

        if src.is_d_present {
            encoder.append_bool(self.d);
        }

        if src.is_e_present {
            encoder.append_bool(self.e);
        }

        if src.is_f_present {
            encoder.append_bool(self.f);
        }

        if src.is_g_present {
            encoder.append_bool(self.g);
        }

        if src.is_h_present {
            encoder.append_bool(self.h);
        }

        if src.is_i_present {
            encoder.append_bool(self.i);
        }
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.is_a_present = decoder.read_bit() != 0;
        self.is_b_present = decoder.read_bit() != 0;
        self.is_c_present = decoder.read_bit() != 0;
        self.is_d_present = decoder.read_bit() != 0;
        self.is_e_present = decoder.read_bit() != 0;
        self.is_f_present = decoder.read_bit() != 0;
        self.is_g_present = decoder.read_bit() != 0;
        self.is_h_present = decoder.read_bit() != 0;
        self.is_i_present = decoder.read_bit() != 0;

        if dst.is_a_present {
            self.a = decoder.read_bool();
        }

        if dst.is_b_present {
            self.b = decoder.read_bool();
        }

        if dst.is_c_present {
            self.c = decoder.read_bool();
        }

        if dst.is_d_present {
            self.d = decoder.read_bool();
        }

        if dst.is_e_present {
            self.e = decoder.read_bool();
        }

        if dst.is_f_present {
            self.f = decoder.read_bool();
        }

        if dst.is_g_present {
            self.g = decoder.read_bool();
        }

        if dst.is_h_present {
            self.h = decoder.read_bool();
        }

        if dst.is_i_present {
            self.i = decoder.read_bool();
        }
    }
}

impl RustSourceH {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        (void)src_p;
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        (void)dst_p;
    }
}

impl RustSourceI {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_bytes(&self.buf,
                             24);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        decoder.read_bytes(&mut self.buf,
                           24);
    }
}

impl RustSourceJ {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            self.length - 22u,
            1);
        encoder.append_bytes(&self.buf,
                             self.length);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.length = decoder.read_non_negative_binary_integer(
            1);
        self.length += 22;
        decoder.read_bytes(&mut self.buf,
                           self.length);
    }
}

impl RustSourceK {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(self.value, 0);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(0);
    }
}

impl RustSourceL {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            self.length - 0u,
            9);
        encoder.append_bytes(&self.buf,
                             self.length);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.length = decoder.read_non_negative_binary_integer(
            9);
        self.length += 0;

        if self.length > 500 {
            decoder.abort(EBADLENGTH);

            return;
        }

        decoder.read_bytes(&mut self.buf,
                           self.length);
    }
}

impl RustSourceO {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        u16 i;

        encoder.append_non_negative_binary_integer(
            self.length - 1u,
            9);

        for i in 0..self.length {
            encoder.append_bool(self.elements[i]);
        }
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        u16 i;

        self.length = decoder.read_non_negative_binary_integer(9);
        self.length += 1;

        if self.length > 260 {
            decoder.abort(EBADLENGTH);

            return;
        }

        for i in 0..self.length {
            self.elements[i] = decoder.read_bool();
        }
    }
}

impl RustSourceN {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        self.a.to_bytes_inner(&mut encoder);
        self.b.to_bytes_inner(&mut encoder);
        self.c.to_bytes_inner(&mut encoder);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.a.from_bytes_inner(&mut decoder);
        self.b.from_bytes_inner(&mut decoder);
        self.c.from_bytes_inner(&mut decoder);
    }
}

impl RustSourceM {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        self.a.to_bytes_inner(&mut encoder);
        self.b.to_bytes_inner(&mut encoder);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.a.from_bytes_inner(&mut decoder);
        self.b.from_bytes_inner(&mut decoder);
    }
}

impl RustSourceP {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        self.a.to_bytes_inner(&mut encoder);
        self.b.to_bytes_inner(&mut encoder);
        self.c.to_bytes_inner(&mut encoder);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.a.from_bytes_inner(&mut decoder);
        self.b.from_bytes_inner(&mut decoder);
        self.c.from_bytes_inner(&mut decoder);
    }
}

impl RustSourceR {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (uint64_t)(self.value - -1),
            1);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(1);
        self.value += -1;
    }
}

impl RustSourceS {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (uint64_t)(self.value - -2),
            2);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(2);
        self.value += -2;
    }
}

impl RustSourceT {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (uint64_t)(self.value - -1),
            2);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(2);
        self.value += -1;
    }
}

impl RustSourceU {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (uint64_t)(self.value - -64),
            7);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(7);
        self.value += -64;
    }
}

impl RustSourceV {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_i8(self.value);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_i8();
    }
}

impl RustSourceW {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (uint64_t)(self.value - -1),
            9);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(9);
        self.value += -1;
    }
}

impl RustSourceX {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (uint64_t)(self.value - -2),
            10);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(10);
        self.value += -2;
    }
}

impl RustSourceY {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (uint64_t)(self.value - 10000),
            10);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(10);
        self.value += 10000;
    }
}

impl RustSourceZ {
    pub fn to_bytes(&mut self,
                    dst: &mut [u8])
                    -> Result<usize, &'static str> {
        let mut encoder = Encoder::new(&mut dst);

        self.to_bytes_inner(&mut encoder);

        return encoder.get_result();
    }

    pub fn from_bytes(&mut self, src: &[u8]) -> Result<usize, &'static str> {
        let mut decoder = Decoder::new(&src);

        self.from_bytes_inner(&mut decoder);

        return decoder.get_result();
    }

    fn to_bytes_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_bool(self.value);
    }

    fn from_bytes_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_bool();
    }
}
