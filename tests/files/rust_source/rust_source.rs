//! This file was generated by asn1tools version 0.145.3 Tue Jan 29 21:03:45 2019.

#[derive(Debug, PartialEq, Copy, Clone)]
pub enum Error {
    BadChoice,
    BadEnum,
    BadLength,
    OutOfData,
    OutOfMemory
}

struct Encoder<'a> {
    buf: &'a mut [u8],
    size: usize,
    pos: usize,
    error: Option<Error>
}

struct Decoder<'a> {
    buf: &'a[u8],
    size: usize,
    pos: usize,
    error: Option<Error>
}

impl<'a> Encoder<'a> {
    fn new(dst: &'a mut [u8]) -> Encoder {
        Encoder {
            size: 8 * dst.len(),
            buf: dst,
            pos: 0,
            error: None
        }
    }

    fn get_result(&self) -> Result<usize, Error> {
        if self.error.is_none() {
            return Ok((self.pos + 7) / 8);
        } else {
            return Err(self.error.unwrap());
        }
    }

    fn abort(&mut self, error: Error) {
        if self.error.is_none() {
            self.error = Some(error);
        }
    }

    fn alloc(&mut self, size: usize) -> Result<usize, ()> {
        if self.pos + size <= self.size {
            let pos = self.pos;
            self.pos += size;
            Ok(pos)
        } else {
            self.abort(Error::OutOfMemory);
            Err(())
        }
    }

    fn append_bit(&mut self, value: u8) {
        if let Ok(pos) = self.alloc(1) {
            if pos % 8 == 0 {
                self.buf[pos / 8] = 0;
            }

            self.buf[pos / 8] |= value << (7 - (pos % 8));
        }
    }

    fn append_bytes(&mut self, buf: &[u8]) {
        if let Ok(pos) = self.alloc(8 * buf.len()) {
            let byte_pos = pos / 8;
            let pos_in_byte = pos % 8;

            if pos_in_byte == 0 {
                self.buf.get_mut(byte_pos..byte_pos + buf.len())
                    .unwrap()
                    .copy_from_slice(buf.get(0..buf.len()).unwrap());
            } else {
                for i in 0..buf.len() {
                    self.buf[byte_pos + i] |= buf[i] >> pos_in_byte;
                    self.buf[byte_pos + i + 1] = buf[i] << (8 - pos_in_byte);
                }
            }
        }
    }

    fn append_u8(&mut self, value: u8) {
        self.append_bytes(&value.to_be_bytes());
    }

    fn append_u16(&mut self, value: u16) {
        self.append_bytes(&value.to_be_bytes());
    }

    fn append_u32(&mut self, value: u32) {
        self.append_bytes(&value.to_be_bytes());
    }

    fn append_u64(&mut self, value: u64) {
        self.append_bytes(&value.to_be_bytes());
    }

    fn append_i8(&mut self, value: i8) {
        self.append_u8((value as u8).wrapping_add(128));
    }

    fn append_i16(&mut self, value: i16) {
        self.append_u16((value as u16).wrapping_add(32768));
    }

    fn append_i32(&mut self, value: i32) {
        self.append_u32((value as u32).wrapping_add(2147483648));
    }

    fn append_i64(&mut self, value: i64) {
        self.append_u64((value as u64).wrapping_add(9223372036854775808));
    }

    fn append_bool(&mut self, value: bool) {
        self.append_bit(value as u8);
    }

    fn append_non_negative_binary_integer(&mut self, value: u64, size: usize) {
        for i in 0..size {
            self.append_bit((value >> (size - i - 1)) as u8 & 1);
        }
    }
}

impl<'a> Decoder<'a> {
    fn new(src: &'a[u8]) -> Decoder {
        Decoder {
            buf: src,
            size: 8 * src.len(),
            pos: 0,
            error: None
        }
    }

    fn get_result(&self) -> Result<usize, Error> {
        if self.error.is_none() {
            Ok((self.pos + 7) / 8)
        } else {
            Err(self.error.unwrap())
        }
    }

    fn abort(&mut self, error: Error) {
        if self.error.is_none() {
            self.error = Some(error);
        }
    }

    fn free(&mut self, size: usize) -> Result<usize, ()> {
        if self.pos + size <= self.size {
            let pos = self.pos;
            self.pos += size;
            Ok(pos)
        } else {
            self.abort(Error::OutOfData);
            Err(())
        }
    }

    fn read_bit(&mut self) -> u8 {
        if let Ok(pos) = self.free(1) {
            (self.buf[pos / 8] >> (7 - (pos % 8))) & 1
        } else {
            0
        }
    }

    fn read_bytes(&mut self, buf: &mut [u8]) {
        if let Ok(pos) = self.free(8 * buf.len()) {
            let byte_pos = pos / 8;
            let pos_in_byte = pos % 8;

            if pos_in_byte == 0 {
                buf.copy_from_slice(
                    self.buf.get(byte_pos..byte_pos + buf.len()).unwrap());
            } else {
                for i in 0..buf.len() {
                    buf[i] = self.buf[byte_pos + i] << pos_in_byte;
                    buf[i] |= self.buf[byte_pos + i + 1] >> (8 - pos_in_byte);
                }
            }
        }
    }

    fn read_u8(&mut self) -> u8 {
        let mut buf = [0; 1];

        self.read_bytes(&mut buf);

        u8::from_be_bytes(buf)
    }

    fn read_u16(&mut self) -> u16 {
        let mut buf = [0; 2];

        self.read_bytes(&mut buf);

        u16::from_be_bytes(buf)
    }

    fn read_u32(&mut self) -> u32 {
        let mut buf = [0; 4];

        self.read_bytes(&mut buf);

        u32::from_be_bytes(buf)
    }

    fn read_u64(&mut self) -> u64 {
        let mut buf = [0; 8];

        self.read_bytes(&mut buf);

        u64::from_be_bytes(buf)
    }

    fn read_i8(&mut self) -> i8 {
        self.read_u8().wrapping_sub(128) as i8
    }

    fn read_i16(&mut self) -> i16 {
        self.read_u16().wrapping_sub(32768) as i16
    }

    fn read_i32(&mut self) -> i32 {
        self.read_u32().wrapping_sub(2147483648) as i32
    }

    fn read_i64(&mut self) -> i64 {
        self.read_u64().wrapping_sub(9223372036854775808) as i64
    }

    fn read_bool(&mut self) -> bool {
        self.read_bit() != 0
    }

    fn read_non_negative_binary_integer(&mut self, size: usize) -> u64 {
        let mut value: u64 = 0;

        for _ in 0..size {
            value <<= 1;
            value |= self.read_bit() as u64;
        }

        value
    }
}

/// Type A in module RustSource.
#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceAJ {
    pub buf: [u8; 11]
}

#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceA {
    pub a: i8,
    pub b: i16,
    pub c: i32,
    pub d: i64,
    pub e: u8,
    pub f: u16,
    pub g: u32,
    pub h: u64,
    pub i: bool,
    pub j: RustSourceAJ
}

impl RustSourceA {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_i8(self.a);
        encoder.append_i16(self.b);
        encoder.append_i32(self.c);
        encoder.append_i64(self.d);
        encoder.append_u8(self.e);
        encoder.append_u16(self.f);
        encoder.append_u32(self.g);
        encoder.append_u64(self.h);
        encoder.append_bool(self.i);
        encoder.append_bytes(&self.j.buf);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.a = decoder.read_i8();
        self.b = decoder.read_i16();
        self.c = decoder.read_i32();
        self.d = decoder.read_i64();
        self.e = decoder.read_u8();
        self.f = decoder.read_u16();
        self.g = decoder.read_u32();
        self.h = decoder.read_u64();
        self.i = decoder.read_bool();
        decoder.read_bytes(&mut self.j.buf);
    }
}

/// Type AB in module RustSource.
#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceAB {
    pub a: i8,
    pub b: u16
}

impl RustSourceAB {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.a - -1) as u64,
            1);
        encoder.append_non_negative_binary_integer(
            (self.b - 10000) as u64,
            10);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.a = decoder.read_non_negative_binary_integer(1) as i8;
        self.a += -1;
        self.b = decoder.read_non_negative_binary_integer(10) as u16;
        self.b += 10000;
    }
}

/// Type D in module RustSource.
let length: u8;
struct {
    enum RustSourceDElemAB_choice_e choice;
    union {
        u8 c;
        bool d;
    } value;
}

struct {
    let length: u8;
}

#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceDElemA {
    pub b: RustSourceDElemAB,
    pub e: RustSourceDElemAE
}

#[derive(Debug, PartialEq, Copy, Clone)]
pub enum RustSourceDElemGH {
    I,
    J,
    K,
}

impl Default for RustSourceDElemGH {
    fn default() -> Self {
        RustSourceDElemGH::I
    }
}

#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceDElemGL {
    let length: u8;
    pub buf: [u8; 2]
}

#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceDElemG {
    pub h: RustSourceDElemGH,
    pub l: RustSourceDElemGL
}

#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceDElemMPQ {
    pub buf: [u8; 5]
}

#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceDElemMP {
    pub q: RustSourceDElemMPQ,
    pub is_r_present: bool,
    pub r: bool
}

#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceDElemM {
    pub is_n_present: bool,
    pub n: bool,
    pub o: i8,
    pub is_p_present: bool,
    pub p: RustSourceDElemMP
}

#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceDElem {
    pub a: RustSourceDElemA,
    pub g: RustSourceDElemG,
    pub m: RustSourceDElemM
} elements[10];

impl RustSourceD {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.length - 1) as u64,
            4);

        for i in 0..self.length {
            match self.elements[i].a.b.choice {
                RustSourceDAB_choice_c_e => {
                    encoder.append_non_negative_binary_integer(0, 1);
                    encoder.append_non_negative_binary_integer(
                        (self.elements[i].a.b.value.c - 0) as u64,
                        1);
                }
                RustSourceDAB_choice_d_e => {
                    encoder.append_non_negative_binary_integer(1, 1);
                    encoder.append_bool(self.elements[i].a.b.value.d);
                }
                _ => encoder.abort(EBADCHOICE);
            }

            encoder.append_non_negative_binary_integer(
                (self.elements[i].a.e.length - 3) as u64,
                1);

            for i_2 in 0..self.elements[i].a.e.length {
            }

            encoder.append_non_negative_binary_integer(self.elements[i].g.h, 2);
            encoder.append_non_negative_binary_integer(
                (self.elements[i].g.l.length - 1) as u64,
                1);
            encoder.append_bytes(&self.elements[i].g.l.buf,
                                 self.elements[i].g.l.length);
            encoder.append_bit(self.elements[i].m.is_n_present as u8);
            encoder.append_bit((self.elements[i].m.o != 3) as u8);
            encoder.append_bit(self.elements[i].m.is_p_present as u8);

            if src.elements[i].m.is_n_present {
                encoder.append_bool(self.elements[i].m.n);
            }

            if src.elements[i].m.o != 3 {
                encoder.append_non_negative_binary_integer(
                    (self.elements[i].m.o - -2) as u64,
                    3);
            }

            if src.elements[i].m.is_p_present {
                encoder.append_bit(self.elements[i].m.p.is_r_present as u8);
                encoder.append_bytes(&self.elements[i].m.p.q.buf);

                if src.elements[i].m.p.is_r_present {
                    encoder.append_bool(self.elements[i].m.p.r);
                }
            }
        }
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.length = decoder.read_non_negative_binary_integer(4);
        self.length += 1;

        if self.length > 10 {
            decoder.abort(EBADLENGTH);

            return;
        }

        for i in 0..self.length {
            choice = decoder.read_non_negative_binary_integer(1);

            match choice {
                0 => {
                    self.elements[i].a.b.choice = RustSourceDAB_choice_c_e;
                    self.elements[i].a.b.value.c = decoder.read_non_negative_binary_integer(1) as u8;
                    self.elements[i].a.b.value.c += 0;
                }
                1 => {
                    self.elements[i].a.b.choice = RustSourceDAB_choice_d_e;
                    self.elements[i].a.b.value.d = decoder.read_bool();
                }
                _ => decoder.abort(EBADCHOICE);
            }

            self.elements[i].a.e.length = decoder.read_non_negative_binary_integer(1);
            self.elements[i].a.e.length += 3;

            for i_2 in 0..self.elements[i].a.e.length {
            }

            self.elements[i].g.h = decoder.read_non_negative_binary_integer(2);
            self.elements[i].g.l.length = decoder.read_non_negative_binary_integer(
                1);
            self.elements[i].g.l.length += 1;
            decoder.read_bytes(&mut self.elements[i].g.l.buf,
                               self.elements[i].g.l.length);
            self.elements[i].m.is_n_present = decoder.read_bit() != 0;
            is_present = decoder.read_bit() == 1;
            self.elements[i].m.is_p_present = decoder.read_bit() != 0;

            if dst.elements[i].m.is_n_present {
                self.elements[i].m.n = decoder.read_bool();
            }

            if is_present {
                self.elements[i].m.o = decoder.read_non_negative_binary_integer(3) as i8;
                self.elements[i].m.o += -2;
            } else {
                dst.elements[i].m.o = 3;
            }

            if dst.elements[i].m.is_p_present {
                self.elements[i].m.p.is_r_present = decoder.read_bit() != 0;
                decoder.read_bytes(&mut self.elements[i].m.p.q.buf);

                if dst.elements[i].m.p.is_r_present {
                    self.elements[i].m.p.r = decoder.read_bool();
                }
            }
        }
    }
}

/// Type Q in module RustSource.
enum RustSourceQ_choice_e choice;
union {
    bool c001;
    bool c002;
    bool c003;
    bool c004;
    bool c005;
    bool c006;
    bool c007;
    bool c008;
    bool c009;
    bool c010;
    bool c011;
    bool c012;
    bool c013;
    bool c014;
    bool c015;
    bool c016;
    bool c017;
    bool c018;
    bool c019;
    bool c020;
    bool c021;
    bool c022;
    bool c023;
    bool c024;
    bool c025;
    bool c026;
    bool c027;
    bool c028;
    bool c029;
    bool c030;
    bool c031;
    bool c032;
    bool c033;
    bool c034;
    bool c035;
    bool c036;
    bool c037;
    bool c038;
    bool c039;
    bool c040;
    bool c041;
    bool c042;
    bool c043;
    bool c044;
    bool c045;
    bool c046;
    bool c047;
    bool c048;
    bool c049;
    bool c050;
    bool c051;
    bool c052;
    bool c053;
    bool c054;
    bool c055;
    bool c056;
    bool c057;
    bool c058;
    bool c059;
    bool c060;
    bool c061;
    bool c062;
    bool c063;
    bool c064;
    bool c065;
    bool c066;
    bool c067;
    bool c068;
    bool c069;
    bool c070;
    bool c071;
    bool c072;
    bool c073;
    bool c074;
    bool c075;
    bool c076;
    bool c077;
    bool c078;
    bool c079;
    bool c080;
    bool c081;
    bool c082;
    bool c083;
    bool c084;
    bool c085;
    bool c086;
    bool c087;
    bool c088;
    bool c089;
    bool c090;
    bool c091;
    bool c092;
    bool c093;
    bool c094;
    bool c095;
    bool c096;
    bool c097;
    bool c098;
    bool c099;
    bool c100;
    bool c101;
    bool c102;
    bool c103;
    bool c104;
    bool c105;
    bool c106;
    bool c107;
    bool c108;
    bool c109;
    bool c110;
    bool c111;
    bool c112;
    bool c113;
    bool c114;
    bool c115;
    bool c116;
    bool c117;
    bool c118;
    bool c119;
    bool c120;
    bool c121;
    bool c122;
    bool c123;
    bool c124;
    bool c125;
    bool c126;
    bool c127;
    bool c128;
    bool c129;
    bool c130;
    bool c131;
    bool c132;
    bool c133;
    bool c134;
    bool c135;
    bool c136;
    bool c137;
    bool c138;
    bool c139;
    bool c140;
    bool c141;
    bool c142;
    bool c143;
    bool c144;
    bool c145;
    bool c146;
    bool c147;
    bool c148;
    bool c149;
    bool c150;
    bool c151;
    bool c152;
    bool c153;
    bool c154;
    bool c155;
    bool c156;
    bool c157;
    bool c158;
    bool c159;
    bool c160;
    bool c161;
    bool c162;
    bool c163;
    bool c164;
    bool c165;
    bool c166;
    bool c167;
    bool c168;
    bool c169;
    bool c170;
    bool c171;
    bool c172;
    bool c173;
    bool c174;
    bool c175;
    bool c176;
    bool c177;
    bool c178;
    bool c179;
    bool c180;
    bool c181;
    bool c182;
    bool c183;
    bool c184;
    bool c185;
    bool c186;
    bool c187;
    bool c188;
    bool c189;
    bool c190;
    bool c191;
    bool c192;
    bool c193;
    bool c194;
    bool c195;
    bool c196;
    bool c197;
    bool c198;
    bool c199;
    bool c200;
    bool c201;
    bool c202;
    bool c203;
    bool c204;
    bool c205;
    bool c206;
    bool c207;
    bool c208;
    bool c209;
    bool c210;
    bool c211;
    bool c212;
    bool c213;
    bool c214;
    bool c215;
    bool c216;
    bool c217;
    bool c218;
    bool c219;
    bool c220;
    bool c221;
    bool c222;
    bool c223;
    bool c224;
    bool c225;
    bool c226;
    bool c227;
    bool c228;
    bool c229;
    bool c230;
    bool c231;
    bool c232;
    bool c233;
    bool c234;
    bool c235;
    bool c236;
    bool c237;
    bool c238;
    bool c239;
    bool c240;
    bool c241;
    bool c242;
    bool c243;
    bool c244;
    bool c245;
    bool c246;
    bool c247;
    bool c248;
    bool c249;
    bool c250;
    bool c251;
    bool c252;
    bool c253;
    bool c254;
    bool c255;
    bool c256;
    bool c257;
} value;

impl RustSourceQ {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        match self.choice {
            RustSourceQ_choice_c001_e => {
                encoder.append_non_negative_binary_integer(0, 9);
                encoder.append_bool(self.value.c001);
            }
            RustSourceQ_choice_c002_e => {
                encoder.append_non_negative_binary_integer(1, 9);
                encoder.append_bool(self.value.c002);
            }
            RustSourceQ_choice_c003_e => {
                encoder.append_non_negative_binary_integer(2, 9);
                encoder.append_bool(self.value.c003);
            }
            RustSourceQ_choice_c004_e => {
                encoder.append_non_negative_binary_integer(3, 9);
                encoder.append_bool(self.value.c004);
            }
            RustSourceQ_choice_c005_e => {
                encoder.append_non_negative_binary_integer(4, 9);
                encoder.append_bool(self.value.c005);
            }
            RustSourceQ_choice_c006_e => {
                encoder.append_non_negative_binary_integer(5, 9);
                encoder.append_bool(self.value.c006);
            }
            RustSourceQ_choice_c007_e => {
                encoder.append_non_negative_binary_integer(6, 9);
                encoder.append_bool(self.value.c007);
            }
            RustSourceQ_choice_c008_e => {
                encoder.append_non_negative_binary_integer(7, 9);
                encoder.append_bool(self.value.c008);
            }
            RustSourceQ_choice_c009_e => {
                encoder.append_non_negative_binary_integer(8, 9);
                encoder.append_bool(self.value.c009);
            }
            RustSourceQ_choice_c010_e => {
                encoder.append_non_negative_binary_integer(9, 9);
                encoder.append_bool(self.value.c010);
            }
            RustSourceQ_choice_c011_e => {
                encoder.append_non_negative_binary_integer(10, 9);
                encoder.append_bool(self.value.c011);
            }
            RustSourceQ_choice_c012_e => {
                encoder.append_non_negative_binary_integer(11, 9);
                encoder.append_bool(self.value.c012);
            }
            RustSourceQ_choice_c013_e => {
                encoder.append_non_negative_binary_integer(12, 9);
                encoder.append_bool(self.value.c013);
            }
            RustSourceQ_choice_c014_e => {
                encoder.append_non_negative_binary_integer(13, 9);
                encoder.append_bool(self.value.c014);
            }
            RustSourceQ_choice_c015_e => {
                encoder.append_non_negative_binary_integer(14, 9);
                encoder.append_bool(self.value.c015);
            }
            RustSourceQ_choice_c016_e => {
                encoder.append_non_negative_binary_integer(15, 9);
                encoder.append_bool(self.value.c016);
            }
            RustSourceQ_choice_c017_e => {
                encoder.append_non_negative_binary_integer(16, 9);
                encoder.append_bool(self.value.c017);
            }
            RustSourceQ_choice_c018_e => {
                encoder.append_non_negative_binary_integer(17, 9);
                encoder.append_bool(self.value.c018);
            }
            RustSourceQ_choice_c019_e => {
                encoder.append_non_negative_binary_integer(18, 9);
                encoder.append_bool(self.value.c019);
            }
            RustSourceQ_choice_c020_e => {
                encoder.append_non_negative_binary_integer(19, 9);
                encoder.append_bool(self.value.c020);
            }
            RustSourceQ_choice_c021_e => {
                encoder.append_non_negative_binary_integer(20, 9);
                encoder.append_bool(self.value.c021);
            }
            RustSourceQ_choice_c022_e => {
                encoder.append_non_negative_binary_integer(21, 9);
                encoder.append_bool(self.value.c022);
            }
            RustSourceQ_choice_c023_e => {
                encoder.append_non_negative_binary_integer(22, 9);
                encoder.append_bool(self.value.c023);
            }
            RustSourceQ_choice_c024_e => {
                encoder.append_non_negative_binary_integer(23, 9);
                encoder.append_bool(self.value.c024);
            }
            RustSourceQ_choice_c025_e => {
                encoder.append_non_negative_binary_integer(24, 9);
                encoder.append_bool(self.value.c025);
            }
            RustSourceQ_choice_c026_e => {
                encoder.append_non_negative_binary_integer(25, 9);
                encoder.append_bool(self.value.c026);
            }
            RustSourceQ_choice_c027_e => {
                encoder.append_non_negative_binary_integer(26, 9);
                encoder.append_bool(self.value.c027);
            }
            RustSourceQ_choice_c028_e => {
                encoder.append_non_negative_binary_integer(27, 9);
                encoder.append_bool(self.value.c028);
            }
            RustSourceQ_choice_c029_e => {
                encoder.append_non_negative_binary_integer(28, 9);
                encoder.append_bool(self.value.c029);
            }
            RustSourceQ_choice_c030_e => {
                encoder.append_non_negative_binary_integer(29, 9);
                encoder.append_bool(self.value.c030);
            }
            RustSourceQ_choice_c031_e => {
                encoder.append_non_negative_binary_integer(30, 9);
                encoder.append_bool(self.value.c031);
            }
            RustSourceQ_choice_c032_e => {
                encoder.append_non_negative_binary_integer(31, 9);
                encoder.append_bool(self.value.c032);
            }
            RustSourceQ_choice_c033_e => {
                encoder.append_non_negative_binary_integer(32, 9);
                encoder.append_bool(self.value.c033);
            }
            RustSourceQ_choice_c034_e => {
                encoder.append_non_negative_binary_integer(33, 9);
                encoder.append_bool(self.value.c034);
            }
            RustSourceQ_choice_c035_e => {
                encoder.append_non_negative_binary_integer(34, 9);
                encoder.append_bool(self.value.c035);
            }
            RustSourceQ_choice_c036_e => {
                encoder.append_non_negative_binary_integer(35, 9);
                encoder.append_bool(self.value.c036);
            }
            RustSourceQ_choice_c037_e => {
                encoder.append_non_negative_binary_integer(36, 9);
                encoder.append_bool(self.value.c037);
            }
            RustSourceQ_choice_c038_e => {
                encoder.append_non_negative_binary_integer(37, 9);
                encoder.append_bool(self.value.c038);
            }
            RustSourceQ_choice_c039_e => {
                encoder.append_non_negative_binary_integer(38, 9);
                encoder.append_bool(self.value.c039);
            }
            RustSourceQ_choice_c040_e => {
                encoder.append_non_negative_binary_integer(39, 9);
                encoder.append_bool(self.value.c040);
            }
            RustSourceQ_choice_c041_e => {
                encoder.append_non_negative_binary_integer(40, 9);
                encoder.append_bool(self.value.c041);
            }
            RustSourceQ_choice_c042_e => {
                encoder.append_non_negative_binary_integer(41, 9);
                encoder.append_bool(self.value.c042);
            }
            RustSourceQ_choice_c043_e => {
                encoder.append_non_negative_binary_integer(42, 9);
                encoder.append_bool(self.value.c043);
            }
            RustSourceQ_choice_c044_e => {
                encoder.append_non_negative_binary_integer(43, 9);
                encoder.append_bool(self.value.c044);
            }
            RustSourceQ_choice_c045_e => {
                encoder.append_non_negative_binary_integer(44, 9);
                encoder.append_bool(self.value.c045);
            }
            RustSourceQ_choice_c046_e => {
                encoder.append_non_negative_binary_integer(45, 9);
                encoder.append_bool(self.value.c046);
            }
            RustSourceQ_choice_c047_e => {
                encoder.append_non_negative_binary_integer(46, 9);
                encoder.append_bool(self.value.c047);
            }
            RustSourceQ_choice_c048_e => {
                encoder.append_non_negative_binary_integer(47, 9);
                encoder.append_bool(self.value.c048);
            }
            RustSourceQ_choice_c049_e => {
                encoder.append_non_negative_binary_integer(48, 9);
                encoder.append_bool(self.value.c049);
            }
            RustSourceQ_choice_c050_e => {
                encoder.append_non_negative_binary_integer(49, 9);
                encoder.append_bool(self.value.c050);
            }
            RustSourceQ_choice_c051_e => {
                encoder.append_non_negative_binary_integer(50, 9);
                encoder.append_bool(self.value.c051);
            }
            RustSourceQ_choice_c052_e => {
                encoder.append_non_negative_binary_integer(51, 9);
                encoder.append_bool(self.value.c052);
            }
            RustSourceQ_choice_c053_e => {
                encoder.append_non_negative_binary_integer(52, 9);
                encoder.append_bool(self.value.c053);
            }
            RustSourceQ_choice_c054_e => {
                encoder.append_non_negative_binary_integer(53, 9);
                encoder.append_bool(self.value.c054);
            }
            RustSourceQ_choice_c055_e => {
                encoder.append_non_negative_binary_integer(54, 9);
                encoder.append_bool(self.value.c055);
            }
            RustSourceQ_choice_c056_e => {
                encoder.append_non_negative_binary_integer(55, 9);
                encoder.append_bool(self.value.c056);
            }
            RustSourceQ_choice_c057_e => {
                encoder.append_non_negative_binary_integer(56, 9);
                encoder.append_bool(self.value.c057);
            }
            RustSourceQ_choice_c058_e => {
                encoder.append_non_negative_binary_integer(57, 9);
                encoder.append_bool(self.value.c058);
            }
            RustSourceQ_choice_c059_e => {
                encoder.append_non_negative_binary_integer(58, 9);
                encoder.append_bool(self.value.c059);
            }
            RustSourceQ_choice_c060_e => {
                encoder.append_non_negative_binary_integer(59, 9);
                encoder.append_bool(self.value.c060);
            }
            RustSourceQ_choice_c061_e => {
                encoder.append_non_negative_binary_integer(60, 9);
                encoder.append_bool(self.value.c061);
            }
            RustSourceQ_choice_c062_e => {
                encoder.append_non_negative_binary_integer(61, 9);
                encoder.append_bool(self.value.c062);
            }
            RustSourceQ_choice_c063_e => {
                encoder.append_non_negative_binary_integer(62, 9);
                encoder.append_bool(self.value.c063);
            }
            RustSourceQ_choice_c064_e => {
                encoder.append_non_negative_binary_integer(63, 9);
                encoder.append_bool(self.value.c064);
            }
            RustSourceQ_choice_c065_e => {
                encoder.append_non_negative_binary_integer(64, 9);
                encoder.append_bool(self.value.c065);
            }
            RustSourceQ_choice_c066_e => {
                encoder.append_non_negative_binary_integer(65, 9);
                encoder.append_bool(self.value.c066);
            }
            RustSourceQ_choice_c067_e => {
                encoder.append_non_negative_binary_integer(66, 9);
                encoder.append_bool(self.value.c067);
            }
            RustSourceQ_choice_c068_e => {
                encoder.append_non_negative_binary_integer(67, 9);
                encoder.append_bool(self.value.c068);
            }
            RustSourceQ_choice_c069_e => {
                encoder.append_non_negative_binary_integer(68, 9);
                encoder.append_bool(self.value.c069);
            }
            RustSourceQ_choice_c070_e => {
                encoder.append_non_negative_binary_integer(69, 9);
                encoder.append_bool(self.value.c070);
            }
            RustSourceQ_choice_c071_e => {
                encoder.append_non_negative_binary_integer(70, 9);
                encoder.append_bool(self.value.c071);
            }
            RustSourceQ_choice_c072_e => {
                encoder.append_non_negative_binary_integer(71, 9);
                encoder.append_bool(self.value.c072);
            }
            RustSourceQ_choice_c073_e => {
                encoder.append_non_negative_binary_integer(72, 9);
                encoder.append_bool(self.value.c073);
            }
            RustSourceQ_choice_c074_e => {
                encoder.append_non_negative_binary_integer(73, 9);
                encoder.append_bool(self.value.c074);
            }
            RustSourceQ_choice_c075_e => {
                encoder.append_non_negative_binary_integer(74, 9);
                encoder.append_bool(self.value.c075);
            }
            RustSourceQ_choice_c076_e => {
                encoder.append_non_negative_binary_integer(75, 9);
                encoder.append_bool(self.value.c076);
            }
            RustSourceQ_choice_c077_e => {
                encoder.append_non_negative_binary_integer(76, 9);
                encoder.append_bool(self.value.c077);
            }
            RustSourceQ_choice_c078_e => {
                encoder.append_non_negative_binary_integer(77, 9);
                encoder.append_bool(self.value.c078);
            }
            RustSourceQ_choice_c079_e => {
                encoder.append_non_negative_binary_integer(78, 9);
                encoder.append_bool(self.value.c079);
            }
            RustSourceQ_choice_c080_e => {
                encoder.append_non_negative_binary_integer(79, 9);
                encoder.append_bool(self.value.c080);
            }
            RustSourceQ_choice_c081_e => {
                encoder.append_non_negative_binary_integer(80, 9);
                encoder.append_bool(self.value.c081);
            }
            RustSourceQ_choice_c082_e => {
                encoder.append_non_negative_binary_integer(81, 9);
                encoder.append_bool(self.value.c082);
            }
            RustSourceQ_choice_c083_e => {
                encoder.append_non_negative_binary_integer(82, 9);
                encoder.append_bool(self.value.c083);
            }
            RustSourceQ_choice_c084_e => {
                encoder.append_non_negative_binary_integer(83, 9);
                encoder.append_bool(self.value.c084);
            }
            RustSourceQ_choice_c085_e => {
                encoder.append_non_negative_binary_integer(84, 9);
                encoder.append_bool(self.value.c085);
            }
            RustSourceQ_choice_c086_e => {
                encoder.append_non_negative_binary_integer(85, 9);
                encoder.append_bool(self.value.c086);
            }
            RustSourceQ_choice_c087_e => {
                encoder.append_non_negative_binary_integer(86, 9);
                encoder.append_bool(self.value.c087);
            }
            RustSourceQ_choice_c088_e => {
                encoder.append_non_negative_binary_integer(87, 9);
                encoder.append_bool(self.value.c088);
            }
            RustSourceQ_choice_c089_e => {
                encoder.append_non_negative_binary_integer(88, 9);
                encoder.append_bool(self.value.c089);
            }
            RustSourceQ_choice_c090_e => {
                encoder.append_non_negative_binary_integer(89, 9);
                encoder.append_bool(self.value.c090);
            }
            RustSourceQ_choice_c091_e => {
                encoder.append_non_negative_binary_integer(90, 9);
                encoder.append_bool(self.value.c091);
            }
            RustSourceQ_choice_c092_e => {
                encoder.append_non_negative_binary_integer(91, 9);
                encoder.append_bool(self.value.c092);
            }
            RustSourceQ_choice_c093_e => {
                encoder.append_non_negative_binary_integer(92, 9);
                encoder.append_bool(self.value.c093);
            }
            RustSourceQ_choice_c094_e => {
                encoder.append_non_negative_binary_integer(93, 9);
                encoder.append_bool(self.value.c094);
            }
            RustSourceQ_choice_c095_e => {
                encoder.append_non_negative_binary_integer(94, 9);
                encoder.append_bool(self.value.c095);
            }
            RustSourceQ_choice_c096_e => {
                encoder.append_non_negative_binary_integer(95, 9);
                encoder.append_bool(self.value.c096);
            }
            RustSourceQ_choice_c097_e => {
                encoder.append_non_negative_binary_integer(96, 9);
                encoder.append_bool(self.value.c097);
            }
            RustSourceQ_choice_c098_e => {
                encoder.append_non_negative_binary_integer(97, 9);
                encoder.append_bool(self.value.c098);
            }
            RustSourceQ_choice_c099_e => {
                encoder.append_non_negative_binary_integer(98, 9);
                encoder.append_bool(self.value.c099);
            }
            RustSourceQ_choice_c100_e => {
                encoder.append_non_negative_binary_integer(99, 9);
                encoder.append_bool(self.value.c100);
            }
            RustSourceQ_choice_c101_e => {
                encoder.append_non_negative_binary_integer(100, 9);
                encoder.append_bool(self.value.c101);
            }
            RustSourceQ_choice_c102_e => {
                encoder.append_non_negative_binary_integer(101, 9);
                encoder.append_bool(self.value.c102);
            }
            RustSourceQ_choice_c103_e => {
                encoder.append_non_negative_binary_integer(102, 9);
                encoder.append_bool(self.value.c103);
            }
            RustSourceQ_choice_c104_e => {
                encoder.append_non_negative_binary_integer(103, 9);
                encoder.append_bool(self.value.c104);
            }
            RustSourceQ_choice_c105_e => {
                encoder.append_non_negative_binary_integer(104, 9);
                encoder.append_bool(self.value.c105);
            }
            RustSourceQ_choice_c106_e => {
                encoder.append_non_negative_binary_integer(105, 9);
                encoder.append_bool(self.value.c106);
            }
            RustSourceQ_choice_c107_e => {
                encoder.append_non_negative_binary_integer(106, 9);
                encoder.append_bool(self.value.c107);
            }
            RustSourceQ_choice_c108_e => {
                encoder.append_non_negative_binary_integer(107, 9);
                encoder.append_bool(self.value.c108);
            }
            RustSourceQ_choice_c109_e => {
                encoder.append_non_negative_binary_integer(108, 9);
                encoder.append_bool(self.value.c109);
            }
            RustSourceQ_choice_c110_e => {
                encoder.append_non_negative_binary_integer(109, 9);
                encoder.append_bool(self.value.c110);
            }
            RustSourceQ_choice_c111_e => {
                encoder.append_non_negative_binary_integer(110, 9);
                encoder.append_bool(self.value.c111);
            }
            RustSourceQ_choice_c112_e => {
                encoder.append_non_negative_binary_integer(111, 9);
                encoder.append_bool(self.value.c112);
            }
            RustSourceQ_choice_c113_e => {
                encoder.append_non_negative_binary_integer(112, 9);
                encoder.append_bool(self.value.c113);
            }
            RustSourceQ_choice_c114_e => {
                encoder.append_non_negative_binary_integer(113, 9);
                encoder.append_bool(self.value.c114);
            }
            RustSourceQ_choice_c115_e => {
                encoder.append_non_negative_binary_integer(114, 9);
                encoder.append_bool(self.value.c115);
            }
            RustSourceQ_choice_c116_e => {
                encoder.append_non_negative_binary_integer(115, 9);
                encoder.append_bool(self.value.c116);
            }
            RustSourceQ_choice_c117_e => {
                encoder.append_non_negative_binary_integer(116, 9);
                encoder.append_bool(self.value.c117);
            }
            RustSourceQ_choice_c118_e => {
                encoder.append_non_negative_binary_integer(117, 9);
                encoder.append_bool(self.value.c118);
            }
            RustSourceQ_choice_c119_e => {
                encoder.append_non_negative_binary_integer(118, 9);
                encoder.append_bool(self.value.c119);
            }
            RustSourceQ_choice_c120_e => {
                encoder.append_non_negative_binary_integer(119, 9);
                encoder.append_bool(self.value.c120);
            }
            RustSourceQ_choice_c121_e => {
                encoder.append_non_negative_binary_integer(120, 9);
                encoder.append_bool(self.value.c121);
            }
            RustSourceQ_choice_c122_e => {
                encoder.append_non_negative_binary_integer(121, 9);
                encoder.append_bool(self.value.c122);
            }
            RustSourceQ_choice_c123_e => {
                encoder.append_non_negative_binary_integer(122, 9);
                encoder.append_bool(self.value.c123);
            }
            RustSourceQ_choice_c124_e => {
                encoder.append_non_negative_binary_integer(123, 9);
                encoder.append_bool(self.value.c124);
            }
            RustSourceQ_choice_c125_e => {
                encoder.append_non_negative_binary_integer(124, 9);
                encoder.append_bool(self.value.c125);
            }
            RustSourceQ_choice_c126_e => {
                encoder.append_non_negative_binary_integer(125, 9);
                encoder.append_bool(self.value.c126);
            }
            RustSourceQ_choice_c127_e => {
                encoder.append_non_negative_binary_integer(126, 9);
                encoder.append_bool(self.value.c127);
            }
            RustSourceQ_choice_c128_e => {
                encoder.append_non_negative_binary_integer(127, 9);
                encoder.append_bool(self.value.c128);
            }
            RustSourceQ_choice_c129_e => {
                encoder.append_non_negative_binary_integer(128, 9);
                encoder.append_bool(self.value.c129);
            }
            RustSourceQ_choice_c130_e => {
                encoder.append_non_negative_binary_integer(129, 9);
                encoder.append_bool(self.value.c130);
            }
            RustSourceQ_choice_c131_e => {
                encoder.append_non_negative_binary_integer(130, 9);
                encoder.append_bool(self.value.c131);
            }
            RustSourceQ_choice_c132_e => {
                encoder.append_non_negative_binary_integer(131, 9);
                encoder.append_bool(self.value.c132);
            }
            RustSourceQ_choice_c133_e => {
                encoder.append_non_negative_binary_integer(132, 9);
                encoder.append_bool(self.value.c133);
            }
            RustSourceQ_choice_c134_e => {
                encoder.append_non_negative_binary_integer(133, 9);
                encoder.append_bool(self.value.c134);
            }
            RustSourceQ_choice_c135_e => {
                encoder.append_non_negative_binary_integer(134, 9);
                encoder.append_bool(self.value.c135);
            }
            RustSourceQ_choice_c136_e => {
                encoder.append_non_negative_binary_integer(135, 9);
                encoder.append_bool(self.value.c136);
            }
            RustSourceQ_choice_c137_e => {
                encoder.append_non_negative_binary_integer(136, 9);
                encoder.append_bool(self.value.c137);
            }
            RustSourceQ_choice_c138_e => {
                encoder.append_non_negative_binary_integer(137, 9);
                encoder.append_bool(self.value.c138);
            }
            RustSourceQ_choice_c139_e => {
                encoder.append_non_negative_binary_integer(138, 9);
                encoder.append_bool(self.value.c139);
            }
            RustSourceQ_choice_c140_e => {
                encoder.append_non_negative_binary_integer(139, 9);
                encoder.append_bool(self.value.c140);
            }
            RustSourceQ_choice_c141_e => {
                encoder.append_non_negative_binary_integer(140, 9);
                encoder.append_bool(self.value.c141);
            }
            RustSourceQ_choice_c142_e => {
                encoder.append_non_negative_binary_integer(141, 9);
                encoder.append_bool(self.value.c142);
            }
            RustSourceQ_choice_c143_e => {
                encoder.append_non_negative_binary_integer(142, 9);
                encoder.append_bool(self.value.c143);
            }
            RustSourceQ_choice_c144_e => {
                encoder.append_non_negative_binary_integer(143, 9);
                encoder.append_bool(self.value.c144);
            }
            RustSourceQ_choice_c145_e => {
                encoder.append_non_negative_binary_integer(144, 9);
                encoder.append_bool(self.value.c145);
            }
            RustSourceQ_choice_c146_e => {
                encoder.append_non_negative_binary_integer(145, 9);
                encoder.append_bool(self.value.c146);
            }
            RustSourceQ_choice_c147_e => {
                encoder.append_non_negative_binary_integer(146, 9);
                encoder.append_bool(self.value.c147);
            }
            RustSourceQ_choice_c148_e => {
                encoder.append_non_negative_binary_integer(147, 9);
                encoder.append_bool(self.value.c148);
            }
            RustSourceQ_choice_c149_e => {
                encoder.append_non_negative_binary_integer(148, 9);
                encoder.append_bool(self.value.c149);
            }
            RustSourceQ_choice_c150_e => {
                encoder.append_non_negative_binary_integer(149, 9);
                encoder.append_bool(self.value.c150);
            }
            RustSourceQ_choice_c151_e => {
                encoder.append_non_negative_binary_integer(150, 9);
                encoder.append_bool(self.value.c151);
            }
            RustSourceQ_choice_c152_e => {
                encoder.append_non_negative_binary_integer(151, 9);
                encoder.append_bool(self.value.c152);
            }
            RustSourceQ_choice_c153_e => {
                encoder.append_non_negative_binary_integer(152, 9);
                encoder.append_bool(self.value.c153);
            }
            RustSourceQ_choice_c154_e => {
                encoder.append_non_negative_binary_integer(153, 9);
                encoder.append_bool(self.value.c154);
            }
            RustSourceQ_choice_c155_e => {
                encoder.append_non_negative_binary_integer(154, 9);
                encoder.append_bool(self.value.c155);
            }
            RustSourceQ_choice_c156_e => {
                encoder.append_non_negative_binary_integer(155, 9);
                encoder.append_bool(self.value.c156);
            }
            RustSourceQ_choice_c157_e => {
                encoder.append_non_negative_binary_integer(156, 9);
                encoder.append_bool(self.value.c157);
            }
            RustSourceQ_choice_c158_e => {
                encoder.append_non_negative_binary_integer(157, 9);
                encoder.append_bool(self.value.c158);
            }
            RustSourceQ_choice_c159_e => {
                encoder.append_non_negative_binary_integer(158, 9);
                encoder.append_bool(self.value.c159);
            }
            RustSourceQ_choice_c160_e => {
                encoder.append_non_negative_binary_integer(159, 9);
                encoder.append_bool(self.value.c160);
            }
            RustSourceQ_choice_c161_e => {
                encoder.append_non_negative_binary_integer(160, 9);
                encoder.append_bool(self.value.c161);
            }
            RustSourceQ_choice_c162_e => {
                encoder.append_non_negative_binary_integer(161, 9);
                encoder.append_bool(self.value.c162);
            }
            RustSourceQ_choice_c163_e => {
                encoder.append_non_negative_binary_integer(162, 9);
                encoder.append_bool(self.value.c163);
            }
            RustSourceQ_choice_c164_e => {
                encoder.append_non_negative_binary_integer(163, 9);
                encoder.append_bool(self.value.c164);
            }
            RustSourceQ_choice_c165_e => {
                encoder.append_non_negative_binary_integer(164, 9);
                encoder.append_bool(self.value.c165);
            }
            RustSourceQ_choice_c166_e => {
                encoder.append_non_negative_binary_integer(165, 9);
                encoder.append_bool(self.value.c166);
            }
            RustSourceQ_choice_c167_e => {
                encoder.append_non_negative_binary_integer(166, 9);
                encoder.append_bool(self.value.c167);
            }
            RustSourceQ_choice_c168_e => {
                encoder.append_non_negative_binary_integer(167, 9);
                encoder.append_bool(self.value.c168);
            }
            RustSourceQ_choice_c169_e => {
                encoder.append_non_negative_binary_integer(168, 9);
                encoder.append_bool(self.value.c169);
            }
            RustSourceQ_choice_c170_e => {
                encoder.append_non_negative_binary_integer(169, 9);
                encoder.append_bool(self.value.c170);
            }
            RustSourceQ_choice_c171_e => {
                encoder.append_non_negative_binary_integer(170, 9);
                encoder.append_bool(self.value.c171);
            }
            RustSourceQ_choice_c172_e => {
                encoder.append_non_negative_binary_integer(171, 9);
                encoder.append_bool(self.value.c172);
            }
            RustSourceQ_choice_c173_e => {
                encoder.append_non_negative_binary_integer(172, 9);
                encoder.append_bool(self.value.c173);
            }
            RustSourceQ_choice_c174_e => {
                encoder.append_non_negative_binary_integer(173, 9);
                encoder.append_bool(self.value.c174);
            }
            RustSourceQ_choice_c175_e => {
                encoder.append_non_negative_binary_integer(174, 9);
                encoder.append_bool(self.value.c175);
            }
            RustSourceQ_choice_c176_e => {
                encoder.append_non_negative_binary_integer(175, 9);
                encoder.append_bool(self.value.c176);
            }
            RustSourceQ_choice_c177_e => {
                encoder.append_non_negative_binary_integer(176, 9);
                encoder.append_bool(self.value.c177);
            }
            RustSourceQ_choice_c178_e => {
                encoder.append_non_negative_binary_integer(177, 9);
                encoder.append_bool(self.value.c178);
            }
            RustSourceQ_choice_c179_e => {
                encoder.append_non_negative_binary_integer(178, 9);
                encoder.append_bool(self.value.c179);
            }
            RustSourceQ_choice_c180_e => {
                encoder.append_non_negative_binary_integer(179, 9);
                encoder.append_bool(self.value.c180);
            }
            RustSourceQ_choice_c181_e => {
                encoder.append_non_negative_binary_integer(180, 9);
                encoder.append_bool(self.value.c181);
            }
            RustSourceQ_choice_c182_e => {
                encoder.append_non_negative_binary_integer(181, 9);
                encoder.append_bool(self.value.c182);
            }
            RustSourceQ_choice_c183_e => {
                encoder.append_non_negative_binary_integer(182, 9);
                encoder.append_bool(self.value.c183);
            }
            RustSourceQ_choice_c184_e => {
                encoder.append_non_negative_binary_integer(183, 9);
                encoder.append_bool(self.value.c184);
            }
            RustSourceQ_choice_c185_e => {
                encoder.append_non_negative_binary_integer(184, 9);
                encoder.append_bool(self.value.c185);
            }
            RustSourceQ_choice_c186_e => {
                encoder.append_non_negative_binary_integer(185, 9);
                encoder.append_bool(self.value.c186);
            }
            RustSourceQ_choice_c187_e => {
                encoder.append_non_negative_binary_integer(186, 9);
                encoder.append_bool(self.value.c187);
            }
            RustSourceQ_choice_c188_e => {
                encoder.append_non_negative_binary_integer(187, 9);
                encoder.append_bool(self.value.c188);
            }
            RustSourceQ_choice_c189_e => {
                encoder.append_non_negative_binary_integer(188, 9);
                encoder.append_bool(self.value.c189);
            }
            RustSourceQ_choice_c190_e => {
                encoder.append_non_negative_binary_integer(189, 9);
                encoder.append_bool(self.value.c190);
            }
            RustSourceQ_choice_c191_e => {
                encoder.append_non_negative_binary_integer(190, 9);
                encoder.append_bool(self.value.c191);
            }
            RustSourceQ_choice_c192_e => {
                encoder.append_non_negative_binary_integer(191, 9);
                encoder.append_bool(self.value.c192);
            }
            RustSourceQ_choice_c193_e => {
                encoder.append_non_negative_binary_integer(192, 9);
                encoder.append_bool(self.value.c193);
            }
            RustSourceQ_choice_c194_e => {
                encoder.append_non_negative_binary_integer(193, 9);
                encoder.append_bool(self.value.c194);
            }
            RustSourceQ_choice_c195_e => {
                encoder.append_non_negative_binary_integer(194, 9);
                encoder.append_bool(self.value.c195);
            }
            RustSourceQ_choice_c196_e => {
                encoder.append_non_negative_binary_integer(195, 9);
                encoder.append_bool(self.value.c196);
            }
            RustSourceQ_choice_c197_e => {
                encoder.append_non_negative_binary_integer(196, 9);
                encoder.append_bool(self.value.c197);
            }
            RustSourceQ_choice_c198_e => {
                encoder.append_non_negative_binary_integer(197, 9);
                encoder.append_bool(self.value.c198);
            }
            RustSourceQ_choice_c199_e => {
                encoder.append_non_negative_binary_integer(198, 9);
                encoder.append_bool(self.value.c199);
            }
            RustSourceQ_choice_c200_e => {
                encoder.append_non_negative_binary_integer(199, 9);
                encoder.append_bool(self.value.c200);
            }
            RustSourceQ_choice_c201_e => {
                encoder.append_non_negative_binary_integer(200, 9);
                encoder.append_bool(self.value.c201);
            }
            RustSourceQ_choice_c202_e => {
                encoder.append_non_negative_binary_integer(201, 9);
                encoder.append_bool(self.value.c202);
            }
            RustSourceQ_choice_c203_e => {
                encoder.append_non_negative_binary_integer(202, 9);
                encoder.append_bool(self.value.c203);
            }
            RustSourceQ_choice_c204_e => {
                encoder.append_non_negative_binary_integer(203, 9);
                encoder.append_bool(self.value.c204);
            }
            RustSourceQ_choice_c205_e => {
                encoder.append_non_negative_binary_integer(204, 9);
                encoder.append_bool(self.value.c205);
            }
            RustSourceQ_choice_c206_e => {
                encoder.append_non_negative_binary_integer(205, 9);
                encoder.append_bool(self.value.c206);
            }
            RustSourceQ_choice_c207_e => {
                encoder.append_non_negative_binary_integer(206, 9);
                encoder.append_bool(self.value.c207);
            }
            RustSourceQ_choice_c208_e => {
                encoder.append_non_negative_binary_integer(207, 9);
                encoder.append_bool(self.value.c208);
            }
            RustSourceQ_choice_c209_e => {
                encoder.append_non_negative_binary_integer(208, 9);
                encoder.append_bool(self.value.c209);
            }
            RustSourceQ_choice_c210_e => {
                encoder.append_non_negative_binary_integer(209, 9);
                encoder.append_bool(self.value.c210);
            }
            RustSourceQ_choice_c211_e => {
                encoder.append_non_negative_binary_integer(210, 9);
                encoder.append_bool(self.value.c211);
            }
            RustSourceQ_choice_c212_e => {
                encoder.append_non_negative_binary_integer(211, 9);
                encoder.append_bool(self.value.c212);
            }
            RustSourceQ_choice_c213_e => {
                encoder.append_non_negative_binary_integer(212, 9);
                encoder.append_bool(self.value.c213);
            }
            RustSourceQ_choice_c214_e => {
                encoder.append_non_negative_binary_integer(213, 9);
                encoder.append_bool(self.value.c214);
            }
            RustSourceQ_choice_c215_e => {
                encoder.append_non_negative_binary_integer(214, 9);
                encoder.append_bool(self.value.c215);
            }
            RustSourceQ_choice_c216_e => {
                encoder.append_non_negative_binary_integer(215, 9);
                encoder.append_bool(self.value.c216);
            }
            RustSourceQ_choice_c217_e => {
                encoder.append_non_negative_binary_integer(216, 9);
                encoder.append_bool(self.value.c217);
            }
            RustSourceQ_choice_c218_e => {
                encoder.append_non_negative_binary_integer(217, 9);
                encoder.append_bool(self.value.c218);
            }
            RustSourceQ_choice_c219_e => {
                encoder.append_non_negative_binary_integer(218, 9);
                encoder.append_bool(self.value.c219);
            }
            RustSourceQ_choice_c220_e => {
                encoder.append_non_negative_binary_integer(219, 9);
                encoder.append_bool(self.value.c220);
            }
            RustSourceQ_choice_c221_e => {
                encoder.append_non_negative_binary_integer(220, 9);
                encoder.append_bool(self.value.c221);
            }
            RustSourceQ_choice_c222_e => {
                encoder.append_non_negative_binary_integer(221, 9);
                encoder.append_bool(self.value.c222);
            }
            RustSourceQ_choice_c223_e => {
                encoder.append_non_negative_binary_integer(222, 9);
                encoder.append_bool(self.value.c223);
            }
            RustSourceQ_choice_c224_e => {
                encoder.append_non_negative_binary_integer(223, 9);
                encoder.append_bool(self.value.c224);
            }
            RustSourceQ_choice_c225_e => {
                encoder.append_non_negative_binary_integer(224, 9);
                encoder.append_bool(self.value.c225);
            }
            RustSourceQ_choice_c226_e => {
                encoder.append_non_negative_binary_integer(225, 9);
                encoder.append_bool(self.value.c226);
            }
            RustSourceQ_choice_c227_e => {
                encoder.append_non_negative_binary_integer(226, 9);
                encoder.append_bool(self.value.c227);
            }
            RustSourceQ_choice_c228_e => {
                encoder.append_non_negative_binary_integer(227, 9);
                encoder.append_bool(self.value.c228);
            }
            RustSourceQ_choice_c229_e => {
                encoder.append_non_negative_binary_integer(228, 9);
                encoder.append_bool(self.value.c229);
            }
            RustSourceQ_choice_c230_e => {
                encoder.append_non_negative_binary_integer(229, 9);
                encoder.append_bool(self.value.c230);
            }
            RustSourceQ_choice_c231_e => {
                encoder.append_non_negative_binary_integer(230, 9);
                encoder.append_bool(self.value.c231);
            }
            RustSourceQ_choice_c232_e => {
                encoder.append_non_negative_binary_integer(231, 9);
                encoder.append_bool(self.value.c232);
            }
            RustSourceQ_choice_c233_e => {
                encoder.append_non_negative_binary_integer(232, 9);
                encoder.append_bool(self.value.c233);
            }
            RustSourceQ_choice_c234_e => {
                encoder.append_non_negative_binary_integer(233, 9);
                encoder.append_bool(self.value.c234);
            }
            RustSourceQ_choice_c235_e => {
                encoder.append_non_negative_binary_integer(234, 9);
                encoder.append_bool(self.value.c235);
            }
            RustSourceQ_choice_c236_e => {
                encoder.append_non_negative_binary_integer(235, 9);
                encoder.append_bool(self.value.c236);
            }
            RustSourceQ_choice_c237_e => {
                encoder.append_non_negative_binary_integer(236, 9);
                encoder.append_bool(self.value.c237);
            }
            RustSourceQ_choice_c238_e => {
                encoder.append_non_negative_binary_integer(237, 9);
                encoder.append_bool(self.value.c238);
            }
            RustSourceQ_choice_c239_e => {
                encoder.append_non_negative_binary_integer(238, 9);
                encoder.append_bool(self.value.c239);
            }
            RustSourceQ_choice_c240_e => {
                encoder.append_non_negative_binary_integer(239, 9);
                encoder.append_bool(self.value.c240);
            }
            RustSourceQ_choice_c241_e => {
                encoder.append_non_negative_binary_integer(240, 9);
                encoder.append_bool(self.value.c241);
            }
            RustSourceQ_choice_c242_e => {
                encoder.append_non_negative_binary_integer(241, 9);
                encoder.append_bool(self.value.c242);
            }
            RustSourceQ_choice_c243_e => {
                encoder.append_non_negative_binary_integer(242, 9);
                encoder.append_bool(self.value.c243);
            }
            RustSourceQ_choice_c244_e => {
                encoder.append_non_negative_binary_integer(243, 9);
                encoder.append_bool(self.value.c244);
            }
            RustSourceQ_choice_c245_e => {
                encoder.append_non_negative_binary_integer(244, 9);
                encoder.append_bool(self.value.c245);
            }
            RustSourceQ_choice_c246_e => {
                encoder.append_non_negative_binary_integer(245, 9);
                encoder.append_bool(self.value.c246);
            }
            RustSourceQ_choice_c247_e => {
                encoder.append_non_negative_binary_integer(246, 9);
                encoder.append_bool(self.value.c247);
            }
            RustSourceQ_choice_c248_e => {
                encoder.append_non_negative_binary_integer(247, 9);
                encoder.append_bool(self.value.c248);
            }
            RustSourceQ_choice_c249_e => {
                encoder.append_non_negative_binary_integer(248, 9);
                encoder.append_bool(self.value.c249);
            }
            RustSourceQ_choice_c250_e => {
                encoder.append_non_negative_binary_integer(249, 9);
                encoder.append_bool(self.value.c250);
            }
            RustSourceQ_choice_c251_e => {
                encoder.append_non_negative_binary_integer(250, 9);
                encoder.append_bool(self.value.c251);
            }
            RustSourceQ_choice_c252_e => {
                encoder.append_non_negative_binary_integer(251, 9);
                encoder.append_bool(self.value.c252);
            }
            RustSourceQ_choice_c253_e => {
                encoder.append_non_negative_binary_integer(252, 9);
                encoder.append_bool(self.value.c253);
            }
            RustSourceQ_choice_c254_e => {
                encoder.append_non_negative_binary_integer(253, 9);
                encoder.append_bool(self.value.c254);
            }
            RustSourceQ_choice_c255_e => {
                encoder.append_non_negative_binary_integer(254, 9);
                encoder.append_bool(self.value.c255);
            }
            RustSourceQ_choice_c256_e => {
                encoder.append_non_negative_binary_integer(255, 9);
                encoder.append_bool(self.value.c256);
            }
            RustSourceQ_choice_c257_e => {
                encoder.append_non_negative_binary_integer(256, 9);
                encoder.append_bool(self.value.c257);
            }
            _ => encoder.abort(EBADCHOICE);
        }
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        choice = decoder.read_non_negative_binary_integer(9);

        match choice {
            0 => {
                self.choice = RustSourceQ_choice_c001_e;
                self.value.c001 = decoder.read_bool();
            }
            1 => {
                self.choice = RustSourceQ_choice_c002_e;
                self.value.c002 = decoder.read_bool();
            }
            2 => {
                self.choice = RustSourceQ_choice_c003_e;
                self.value.c003 = decoder.read_bool();
            }
            3 => {
                self.choice = RustSourceQ_choice_c004_e;
                self.value.c004 = decoder.read_bool();
            }
            4 => {
                self.choice = RustSourceQ_choice_c005_e;
                self.value.c005 = decoder.read_bool();
            }
            5 => {
                self.choice = RustSourceQ_choice_c006_e;
                self.value.c006 = decoder.read_bool();
            }
            6 => {
                self.choice = RustSourceQ_choice_c007_e;
                self.value.c007 = decoder.read_bool();
            }
            7 => {
                self.choice = RustSourceQ_choice_c008_e;
                self.value.c008 = decoder.read_bool();
            }
            8 => {
                self.choice = RustSourceQ_choice_c009_e;
                self.value.c009 = decoder.read_bool();
            }
            9 => {
                self.choice = RustSourceQ_choice_c010_e;
                self.value.c010 = decoder.read_bool();
            }
            10 => {
                self.choice = RustSourceQ_choice_c011_e;
                self.value.c011 = decoder.read_bool();
            }
            11 => {
                self.choice = RustSourceQ_choice_c012_e;
                self.value.c012 = decoder.read_bool();
            }
            12 => {
                self.choice = RustSourceQ_choice_c013_e;
                self.value.c013 = decoder.read_bool();
            }
            13 => {
                self.choice = RustSourceQ_choice_c014_e;
                self.value.c014 = decoder.read_bool();
            }
            14 => {
                self.choice = RustSourceQ_choice_c015_e;
                self.value.c015 = decoder.read_bool();
            }
            15 => {
                self.choice = RustSourceQ_choice_c016_e;
                self.value.c016 = decoder.read_bool();
            }
            16 => {
                self.choice = RustSourceQ_choice_c017_e;
                self.value.c017 = decoder.read_bool();
            }
            17 => {
                self.choice = RustSourceQ_choice_c018_e;
                self.value.c018 = decoder.read_bool();
            }
            18 => {
                self.choice = RustSourceQ_choice_c019_e;
                self.value.c019 = decoder.read_bool();
            }
            19 => {
                self.choice = RustSourceQ_choice_c020_e;
                self.value.c020 = decoder.read_bool();
            }
            20 => {
                self.choice = RustSourceQ_choice_c021_e;
                self.value.c021 = decoder.read_bool();
            }
            21 => {
                self.choice = RustSourceQ_choice_c022_e;
                self.value.c022 = decoder.read_bool();
            }
            22 => {
                self.choice = RustSourceQ_choice_c023_e;
                self.value.c023 = decoder.read_bool();
            }
            23 => {
                self.choice = RustSourceQ_choice_c024_e;
                self.value.c024 = decoder.read_bool();
            }
            24 => {
                self.choice = RustSourceQ_choice_c025_e;
                self.value.c025 = decoder.read_bool();
            }
            25 => {
                self.choice = RustSourceQ_choice_c026_e;
                self.value.c026 = decoder.read_bool();
            }
            26 => {
                self.choice = RustSourceQ_choice_c027_e;
                self.value.c027 = decoder.read_bool();
            }
            27 => {
                self.choice = RustSourceQ_choice_c028_e;
                self.value.c028 = decoder.read_bool();
            }
            28 => {
                self.choice = RustSourceQ_choice_c029_e;
                self.value.c029 = decoder.read_bool();
            }
            29 => {
                self.choice = RustSourceQ_choice_c030_e;
                self.value.c030 = decoder.read_bool();
            }
            30 => {
                self.choice = RustSourceQ_choice_c031_e;
                self.value.c031 = decoder.read_bool();
            }
            31 => {
                self.choice = RustSourceQ_choice_c032_e;
                self.value.c032 = decoder.read_bool();
            }
            32 => {
                self.choice = RustSourceQ_choice_c033_e;
                self.value.c033 = decoder.read_bool();
            }
            33 => {
                self.choice = RustSourceQ_choice_c034_e;
                self.value.c034 = decoder.read_bool();
            }
            34 => {
                self.choice = RustSourceQ_choice_c035_e;
                self.value.c035 = decoder.read_bool();
            }
            35 => {
                self.choice = RustSourceQ_choice_c036_e;
                self.value.c036 = decoder.read_bool();
            }
            36 => {
                self.choice = RustSourceQ_choice_c037_e;
                self.value.c037 = decoder.read_bool();
            }
            37 => {
                self.choice = RustSourceQ_choice_c038_e;
                self.value.c038 = decoder.read_bool();
            }
            38 => {
                self.choice = RustSourceQ_choice_c039_e;
                self.value.c039 = decoder.read_bool();
            }
            39 => {
                self.choice = RustSourceQ_choice_c040_e;
                self.value.c040 = decoder.read_bool();
            }
            40 => {
                self.choice = RustSourceQ_choice_c041_e;
                self.value.c041 = decoder.read_bool();
            }
            41 => {
                self.choice = RustSourceQ_choice_c042_e;
                self.value.c042 = decoder.read_bool();
            }
            42 => {
                self.choice = RustSourceQ_choice_c043_e;
                self.value.c043 = decoder.read_bool();
            }
            43 => {
                self.choice = RustSourceQ_choice_c044_e;
                self.value.c044 = decoder.read_bool();
            }
            44 => {
                self.choice = RustSourceQ_choice_c045_e;
                self.value.c045 = decoder.read_bool();
            }
            45 => {
                self.choice = RustSourceQ_choice_c046_e;
                self.value.c046 = decoder.read_bool();
            }
            46 => {
                self.choice = RustSourceQ_choice_c047_e;
                self.value.c047 = decoder.read_bool();
            }
            47 => {
                self.choice = RustSourceQ_choice_c048_e;
                self.value.c048 = decoder.read_bool();
            }
            48 => {
                self.choice = RustSourceQ_choice_c049_e;
                self.value.c049 = decoder.read_bool();
            }
            49 => {
                self.choice = RustSourceQ_choice_c050_e;
                self.value.c050 = decoder.read_bool();
            }
            50 => {
                self.choice = RustSourceQ_choice_c051_e;
                self.value.c051 = decoder.read_bool();
            }
            51 => {
                self.choice = RustSourceQ_choice_c052_e;
                self.value.c052 = decoder.read_bool();
            }
            52 => {
                self.choice = RustSourceQ_choice_c053_e;
                self.value.c053 = decoder.read_bool();
            }
            53 => {
                self.choice = RustSourceQ_choice_c054_e;
                self.value.c054 = decoder.read_bool();
            }
            54 => {
                self.choice = RustSourceQ_choice_c055_e;
                self.value.c055 = decoder.read_bool();
            }
            55 => {
                self.choice = RustSourceQ_choice_c056_e;
                self.value.c056 = decoder.read_bool();
            }
            56 => {
                self.choice = RustSourceQ_choice_c057_e;
                self.value.c057 = decoder.read_bool();
            }
            57 => {
                self.choice = RustSourceQ_choice_c058_e;
                self.value.c058 = decoder.read_bool();
            }
            58 => {
                self.choice = RustSourceQ_choice_c059_e;
                self.value.c059 = decoder.read_bool();
            }
            59 => {
                self.choice = RustSourceQ_choice_c060_e;
                self.value.c060 = decoder.read_bool();
            }
            60 => {
                self.choice = RustSourceQ_choice_c061_e;
                self.value.c061 = decoder.read_bool();
            }
            61 => {
                self.choice = RustSourceQ_choice_c062_e;
                self.value.c062 = decoder.read_bool();
            }
            62 => {
                self.choice = RustSourceQ_choice_c063_e;
                self.value.c063 = decoder.read_bool();
            }
            63 => {
                self.choice = RustSourceQ_choice_c064_e;
                self.value.c064 = decoder.read_bool();
            }
            64 => {
                self.choice = RustSourceQ_choice_c065_e;
                self.value.c065 = decoder.read_bool();
            }
            65 => {
                self.choice = RustSourceQ_choice_c066_e;
                self.value.c066 = decoder.read_bool();
            }
            66 => {
                self.choice = RustSourceQ_choice_c067_e;
                self.value.c067 = decoder.read_bool();
            }
            67 => {
                self.choice = RustSourceQ_choice_c068_e;
                self.value.c068 = decoder.read_bool();
            }
            68 => {
                self.choice = RustSourceQ_choice_c069_e;
                self.value.c069 = decoder.read_bool();
            }
            69 => {
                self.choice = RustSourceQ_choice_c070_e;
                self.value.c070 = decoder.read_bool();
            }
            70 => {
                self.choice = RustSourceQ_choice_c071_e;
                self.value.c071 = decoder.read_bool();
            }
            71 => {
                self.choice = RustSourceQ_choice_c072_e;
                self.value.c072 = decoder.read_bool();
            }
            72 => {
                self.choice = RustSourceQ_choice_c073_e;
                self.value.c073 = decoder.read_bool();
            }
            73 => {
                self.choice = RustSourceQ_choice_c074_e;
                self.value.c074 = decoder.read_bool();
            }
            74 => {
                self.choice = RustSourceQ_choice_c075_e;
                self.value.c075 = decoder.read_bool();
            }
            75 => {
                self.choice = RustSourceQ_choice_c076_e;
                self.value.c076 = decoder.read_bool();
            }
            76 => {
                self.choice = RustSourceQ_choice_c077_e;
                self.value.c077 = decoder.read_bool();
            }
            77 => {
                self.choice = RustSourceQ_choice_c078_e;
                self.value.c078 = decoder.read_bool();
            }
            78 => {
                self.choice = RustSourceQ_choice_c079_e;
                self.value.c079 = decoder.read_bool();
            }
            79 => {
                self.choice = RustSourceQ_choice_c080_e;
                self.value.c080 = decoder.read_bool();
            }
            80 => {
                self.choice = RustSourceQ_choice_c081_e;
                self.value.c081 = decoder.read_bool();
            }
            81 => {
                self.choice = RustSourceQ_choice_c082_e;
                self.value.c082 = decoder.read_bool();
            }
            82 => {
                self.choice = RustSourceQ_choice_c083_e;
                self.value.c083 = decoder.read_bool();
            }
            83 => {
                self.choice = RustSourceQ_choice_c084_e;
                self.value.c084 = decoder.read_bool();
            }
            84 => {
                self.choice = RustSourceQ_choice_c085_e;
                self.value.c085 = decoder.read_bool();
            }
            85 => {
                self.choice = RustSourceQ_choice_c086_e;
                self.value.c086 = decoder.read_bool();
            }
            86 => {
                self.choice = RustSourceQ_choice_c087_e;
                self.value.c087 = decoder.read_bool();
            }
            87 => {
                self.choice = RustSourceQ_choice_c088_e;
                self.value.c088 = decoder.read_bool();
            }
            88 => {
                self.choice = RustSourceQ_choice_c089_e;
                self.value.c089 = decoder.read_bool();
            }
            89 => {
                self.choice = RustSourceQ_choice_c090_e;
                self.value.c090 = decoder.read_bool();
            }
            90 => {
                self.choice = RustSourceQ_choice_c091_e;
                self.value.c091 = decoder.read_bool();
            }
            91 => {
                self.choice = RustSourceQ_choice_c092_e;
                self.value.c092 = decoder.read_bool();
            }
            92 => {
                self.choice = RustSourceQ_choice_c093_e;
                self.value.c093 = decoder.read_bool();
            }
            93 => {
                self.choice = RustSourceQ_choice_c094_e;
                self.value.c094 = decoder.read_bool();
            }
            94 => {
                self.choice = RustSourceQ_choice_c095_e;
                self.value.c095 = decoder.read_bool();
            }
            95 => {
                self.choice = RustSourceQ_choice_c096_e;
                self.value.c096 = decoder.read_bool();
            }
            96 => {
                self.choice = RustSourceQ_choice_c097_e;
                self.value.c097 = decoder.read_bool();
            }
            97 => {
                self.choice = RustSourceQ_choice_c098_e;
                self.value.c098 = decoder.read_bool();
            }
            98 => {
                self.choice = RustSourceQ_choice_c099_e;
                self.value.c099 = decoder.read_bool();
            }
            99 => {
                self.choice = RustSourceQ_choice_c100_e;
                self.value.c100 = decoder.read_bool();
            }
            100 => {
                self.choice = RustSourceQ_choice_c101_e;
                self.value.c101 = decoder.read_bool();
            }
            101 => {
                self.choice = RustSourceQ_choice_c102_e;
                self.value.c102 = decoder.read_bool();
            }
            102 => {
                self.choice = RustSourceQ_choice_c103_e;
                self.value.c103 = decoder.read_bool();
            }
            103 => {
                self.choice = RustSourceQ_choice_c104_e;
                self.value.c104 = decoder.read_bool();
            }
            104 => {
                self.choice = RustSourceQ_choice_c105_e;
                self.value.c105 = decoder.read_bool();
            }
            105 => {
                self.choice = RustSourceQ_choice_c106_e;
                self.value.c106 = decoder.read_bool();
            }
            106 => {
                self.choice = RustSourceQ_choice_c107_e;
                self.value.c107 = decoder.read_bool();
            }
            107 => {
                self.choice = RustSourceQ_choice_c108_e;
                self.value.c108 = decoder.read_bool();
            }
            108 => {
                self.choice = RustSourceQ_choice_c109_e;
                self.value.c109 = decoder.read_bool();
            }
            109 => {
                self.choice = RustSourceQ_choice_c110_e;
                self.value.c110 = decoder.read_bool();
            }
            110 => {
                self.choice = RustSourceQ_choice_c111_e;
                self.value.c111 = decoder.read_bool();
            }
            111 => {
                self.choice = RustSourceQ_choice_c112_e;
                self.value.c112 = decoder.read_bool();
            }
            112 => {
                self.choice = RustSourceQ_choice_c113_e;
                self.value.c113 = decoder.read_bool();
            }
            113 => {
                self.choice = RustSourceQ_choice_c114_e;
                self.value.c114 = decoder.read_bool();
            }
            114 => {
                self.choice = RustSourceQ_choice_c115_e;
                self.value.c115 = decoder.read_bool();
            }
            115 => {
                self.choice = RustSourceQ_choice_c116_e;
                self.value.c116 = decoder.read_bool();
            }
            116 => {
                self.choice = RustSourceQ_choice_c117_e;
                self.value.c117 = decoder.read_bool();
            }
            117 => {
                self.choice = RustSourceQ_choice_c118_e;
                self.value.c118 = decoder.read_bool();
            }
            118 => {
                self.choice = RustSourceQ_choice_c119_e;
                self.value.c119 = decoder.read_bool();
            }
            119 => {
                self.choice = RustSourceQ_choice_c120_e;
                self.value.c120 = decoder.read_bool();
            }
            120 => {
                self.choice = RustSourceQ_choice_c121_e;
                self.value.c121 = decoder.read_bool();
            }
            121 => {
                self.choice = RustSourceQ_choice_c122_e;
                self.value.c122 = decoder.read_bool();
            }
            122 => {
                self.choice = RustSourceQ_choice_c123_e;
                self.value.c123 = decoder.read_bool();
            }
            123 => {
                self.choice = RustSourceQ_choice_c124_e;
                self.value.c124 = decoder.read_bool();
            }
            124 => {
                self.choice = RustSourceQ_choice_c125_e;
                self.value.c125 = decoder.read_bool();
            }
            125 => {
                self.choice = RustSourceQ_choice_c126_e;
                self.value.c126 = decoder.read_bool();
            }
            126 => {
                self.choice = RustSourceQ_choice_c127_e;
                self.value.c127 = decoder.read_bool();
            }
            127 => {
                self.choice = RustSourceQ_choice_c128_e;
                self.value.c128 = decoder.read_bool();
            }
            128 => {
                self.choice = RustSourceQ_choice_c129_e;
                self.value.c129 = decoder.read_bool();
            }
            129 => {
                self.choice = RustSourceQ_choice_c130_e;
                self.value.c130 = decoder.read_bool();
            }
            130 => {
                self.choice = RustSourceQ_choice_c131_e;
                self.value.c131 = decoder.read_bool();
            }
            131 => {
                self.choice = RustSourceQ_choice_c132_e;
                self.value.c132 = decoder.read_bool();
            }
            132 => {
                self.choice = RustSourceQ_choice_c133_e;
                self.value.c133 = decoder.read_bool();
            }
            133 => {
                self.choice = RustSourceQ_choice_c134_e;
                self.value.c134 = decoder.read_bool();
            }
            134 => {
                self.choice = RustSourceQ_choice_c135_e;
                self.value.c135 = decoder.read_bool();
            }
            135 => {
                self.choice = RustSourceQ_choice_c136_e;
                self.value.c136 = decoder.read_bool();
            }
            136 => {
                self.choice = RustSourceQ_choice_c137_e;
                self.value.c137 = decoder.read_bool();
            }
            137 => {
                self.choice = RustSourceQ_choice_c138_e;
                self.value.c138 = decoder.read_bool();
            }
            138 => {
                self.choice = RustSourceQ_choice_c139_e;
                self.value.c139 = decoder.read_bool();
            }
            139 => {
                self.choice = RustSourceQ_choice_c140_e;
                self.value.c140 = decoder.read_bool();
            }
            140 => {
                self.choice = RustSourceQ_choice_c141_e;
                self.value.c141 = decoder.read_bool();
            }
            141 => {
                self.choice = RustSourceQ_choice_c142_e;
                self.value.c142 = decoder.read_bool();
            }
            142 => {
                self.choice = RustSourceQ_choice_c143_e;
                self.value.c143 = decoder.read_bool();
            }
            143 => {
                self.choice = RustSourceQ_choice_c144_e;
                self.value.c144 = decoder.read_bool();
            }
            144 => {
                self.choice = RustSourceQ_choice_c145_e;
                self.value.c145 = decoder.read_bool();
            }
            145 => {
                self.choice = RustSourceQ_choice_c146_e;
                self.value.c146 = decoder.read_bool();
            }
            146 => {
                self.choice = RustSourceQ_choice_c147_e;
                self.value.c147 = decoder.read_bool();
            }
            147 => {
                self.choice = RustSourceQ_choice_c148_e;
                self.value.c148 = decoder.read_bool();
            }
            148 => {
                self.choice = RustSourceQ_choice_c149_e;
                self.value.c149 = decoder.read_bool();
            }
            149 => {
                self.choice = RustSourceQ_choice_c150_e;
                self.value.c150 = decoder.read_bool();
            }
            150 => {
                self.choice = RustSourceQ_choice_c151_e;
                self.value.c151 = decoder.read_bool();
            }
            151 => {
                self.choice = RustSourceQ_choice_c152_e;
                self.value.c152 = decoder.read_bool();
            }
            152 => {
                self.choice = RustSourceQ_choice_c153_e;
                self.value.c153 = decoder.read_bool();
            }
            153 => {
                self.choice = RustSourceQ_choice_c154_e;
                self.value.c154 = decoder.read_bool();
            }
            154 => {
                self.choice = RustSourceQ_choice_c155_e;
                self.value.c155 = decoder.read_bool();
            }
            155 => {
                self.choice = RustSourceQ_choice_c156_e;
                self.value.c156 = decoder.read_bool();
            }
            156 => {
                self.choice = RustSourceQ_choice_c157_e;
                self.value.c157 = decoder.read_bool();
            }
            157 => {
                self.choice = RustSourceQ_choice_c158_e;
                self.value.c158 = decoder.read_bool();
            }
            158 => {
                self.choice = RustSourceQ_choice_c159_e;
                self.value.c159 = decoder.read_bool();
            }
            159 => {
                self.choice = RustSourceQ_choice_c160_e;
                self.value.c160 = decoder.read_bool();
            }
            160 => {
                self.choice = RustSourceQ_choice_c161_e;
                self.value.c161 = decoder.read_bool();
            }
            161 => {
                self.choice = RustSourceQ_choice_c162_e;
                self.value.c162 = decoder.read_bool();
            }
            162 => {
                self.choice = RustSourceQ_choice_c163_e;
                self.value.c163 = decoder.read_bool();
            }
            163 => {
                self.choice = RustSourceQ_choice_c164_e;
                self.value.c164 = decoder.read_bool();
            }
            164 => {
                self.choice = RustSourceQ_choice_c165_e;
                self.value.c165 = decoder.read_bool();
            }
            165 => {
                self.choice = RustSourceQ_choice_c166_e;
                self.value.c166 = decoder.read_bool();
            }
            166 => {
                self.choice = RustSourceQ_choice_c167_e;
                self.value.c167 = decoder.read_bool();
            }
            167 => {
                self.choice = RustSourceQ_choice_c168_e;
                self.value.c168 = decoder.read_bool();
            }
            168 => {
                self.choice = RustSourceQ_choice_c169_e;
                self.value.c169 = decoder.read_bool();
            }
            169 => {
                self.choice = RustSourceQ_choice_c170_e;
                self.value.c170 = decoder.read_bool();
            }
            170 => {
                self.choice = RustSourceQ_choice_c171_e;
                self.value.c171 = decoder.read_bool();
            }
            171 => {
                self.choice = RustSourceQ_choice_c172_e;
                self.value.c172 = decoder.read_bool();
            }
            172 => {
                self.choice = RustSourceQ_choice_c173_e;
                self.value.c173 = decoder.read_bool();
            }
            173 => {
                self.choice = RustSourceQ_choice_c174_e;
                self.value.c174 = decoder.read_bool();
            }
            174 => {
                self.choice = RustSourceQ_choice_c175_e;
                self.value.c175 = decoder.read_bool();
            }
            175 => {
                self.choice = RustSourceQ_choice_c176_e;
                self.value.c176 = decoder.read_bool();
            }
            176 => {
                self.choice = RustSourceQ_choice_c177_e;
                self.value.c177 = decoder.read_bool();
            }
            177 => {
                self.choice = RustSourceQ_choice_c178_e;
                self.value.c178 = decoder.read_bool();
            }
            178 => {
                self.choice = RustSourceQ_choice_c179_e;
                self.value.c179 = decoder.read_bool();
            }
            179 => {
                self.choice = RustSourceQ_choice_c180_e;
                self.value.c180 = decoder.read_bool();
            }
            180 => {
                self.choice = RustSourceQ_choice_c181_e;
                self.value.c181 = decoder.read_bool();
            }
            181 => {
                self.choice = RustSourceQ_choice_c182_e;
                self.value.c182 = decoder.read_bool();
            }
            182 => {
                self.choice = RustSourceQ_choice_c183_e;
                self.value.c183 = decoder.read_bool();
            }
            183 => {
                self.choice = RustSourceQ_choice_c184_e;
                self.value.c184 = decoder.read_bool();
            }
            184 => {
                self.choice = RustSourceQ_choice_c185_e;
                self.value.c185 = decoder.read_bool();
            }
            185 => {
                self.choice = RustSourceQ_choice_c186_e;
                self.value.c186 = decoder.read_bool();
            }
            186 => {
                self.choice = RustSourceQ_choice_c187_e;
                self.value.c187 = decoder.read_bool();
            }
            187 => {
                self.choice = RustSourceQ_choice_c188_e;
                self.value.c188 = decoder.read_bool();
            }
            188 => {
                self.choice = RustSourceQ_choice_c189_e;
                self.value.c189 = decoder.read_bool();
            }
            189 => {
                self.choice = RustSourceQ_choice_c190_e;
                self.value.c190 = decoder.read_bool();
            }
            190 => {
                self.choice = RustSourceQ_choice_c191_e;
                self.value.c191 = decoder.read_bool();
            }
            191 => {
                self.choice = RustSourceQ_choice_c192_e;
                self.value.c192 = decoder.read_bool();
            }
            192 => {
                self.choice = RustSourceQ_choice_c193_e;
                self.value.c193 = decoder.read_bool();
            }
            193 => {
                self.choice = RustSourceQ_choice_c194_e;
                self.value.c194 = decoder.read_bool();
            }
            194 => {
                self.choice = RustSourceQ_choice_c195_e;
                self.value.c195 = decoder.read_bool();
            }
            195 => {
                self.choice = RustSourceQ_choice_c196_e;
                self.value.c196 = decoder.read_bool();
            }
            196 => {
                self.choice = RustSourceQ_choice_c197_e;
                self.value.c197 = decoder.read_bool();
            }
            197 => {
                self.choice = RustSourceQ_choice_c198_e;
                self.value.c198 = decoder.read_bool();
            }
            198 => {
                self.choice = RustSourceQ_choice_c199_e;
                self.value.c199 = decoder.read_bool();
            }
            199 => {
                self.choice = RustSourceQ_choice_c200_e;
                self.value.c200 = decoder.read_bool();
            }
            200 => {
                self.choice = RustSourceQ_choice_c201_e;
                self.value.c201 = decoder.read_bool();
            }
            201 => {
                self.choice = RustSourceQ_choice_c202_e;
                self.value.c202 = decoder.read_bool();
            }
            202 => {
                self.choice = RustSourceQ_choice_c203_e;
                self.value.c203 = decoder.read_bool();
            }
            203 => {
                self.choice = RustSourceQ_choice_c204_e;
                self.value.c204 = decoder.read_bool();
            }
            204 => {
                self.choice = RustSourceQ_choice_c205_e;
                self.value.c205 = decoder.read_bool();
            }
            205 => {
                self.choice = RustSourceQ_choice_c206_e;
                self.value.c206 = decoder.read_bool();
            }
            206 => {
                self.choice = RustSourceQ_choice_c207_e;
                self.value.c207 = decoder.read_bool();
            }
            207 => {
                self.choice = RustSourceQ_choice_c208_e;
                self.value.c208 = decoder.read_bool();
            }
            208 => {
                self.choice = RustSourceQ_choice_c209_e;
                self.value.c209 = decoder.read_bool();
            }
            209 => {
                self.choice = RustSourceQ_choice_c210_e;
                self.value.c210 = decoder.read_bool();
            }
            210 => {
                self.choice = RustSourceQ_choice_c211_e;
                self.value.c211 = decoder.read_bool();
            }
            211 => {
                self.choice = RustSourceQ_choice_c212_e;
                self.value.c212 = decoder.read_bool();
            }
            212 => {
                self.choice = RustSourceQ_choice_c213_e;
                self.value.c213 = decoder.read_bool();
            }
            213 => {
                self.choice = RustSourceQ_choice_c214_e;
                self.value.c214 = decoder.read_bool();
            }
            214 => {
                self.choice = RustSourceQ_choice_c215_e;
                self.value.c215 = decoder.read_bool();
            }
            215 => {
                self.choice = RustSourceQ_choice_c216_e;
                self.value.c216 = decoder.read_bool();
            }
            216 => {
                self.choice = RustSourceQ_choice_c217_e;
                self.value.c217 = decoder.read_bool();
            }
            217 => {
                self.choice = RustSourceQ_choice_c218_e;
                self.value.c218 = decoder.read_bool();
            }
            218 => {
                self.choice = RustSourceQ_choice_c219_e;
                self.value.c219 = decoder.read_bool();
            }
            219 => {
                self.choice = RustSourceQ_choice_c220_e;
                self.value.c220 = decoder.read_bool();
            }
            220 => {
                self.choice = RustSourceQ_choice_c221_e;
                self.value.c221 = decoder.read_bool();
            }
            221 => {
                self.choice = RustSourceQ_choice_c222_e;
                self.value.c222 = decoder.read_bool();
            }
            222 => {
                self.choice = RustSourceQ_choice_c223_e;
                self.value.c223 = decoder.read_bool();
            }
            223 => {
                self.choice = RustSourceQ_choice_c224_e;
                self.value.c224 = decoder.read_bool();
            }
            224 => {
                self.choice = RustSourceQ_choice_c225_e;
                self.value.c225 = decoder.read_bool();
            }
            225 => {
                self.choice = RustSourceQ_choice_c226_e;
                self.value.c226 = decoder.read_bool();
            }
            226 => {
                self.choice = RustSourceQ_choice_c227_e;
                self.value.c227 = decoder.read_bool();
            }
            227 => {
                self.choice = RustSourceQ_choice_c228_e;
                self.value.c228 = decoder.read_bool();
            }
            228 => {
                self.choice = RustSourceQ_choice_c229_e;
                self.value.c229 = decoder.read_bool();
            }
            229 => {
                self.choice = RustSourceQ_choice_c230_e;
                self.value.c230 = decoder.read_bool();
            }
            230 => {
                self.choice = RustSourceQ_choice_c231_e;
                self.value.c231 = decoder.read_bool();
            }
            231 => {
                self.choice = RustSourceQ_choice_c232_e;
                self.value.c232 = decoder.read_bool();
            }
            232 => {
                self.choice = RustSourceQ_choice_c233_e;
                self.value.c233 = decoder.read_bool();
            }
            233 => {
                self.choice = RustSourceQ_choice_c234_e;
                self.value.c234 = decoder.read_bool();
            }
            234 => {
                self.choice = RustSourceQ_choice_c235_e;
                self.value.c235 = decoder.read_bool();
            }
            235 => {
                self.choice = RustSourceQ_choice_c236_e;
                self.value.c236 = decoder.read_bool();
            }
            236 => {
                self.choice = RustSourceQ_choice_c237_e;
                self.value.c237 = decoder.read_bool();
            }
            237 => {
                self.choice = RustSourceQ_choice_c238_e;
                self.value.c238 = decoder.read_bool();
            }
            238 => {
                self.choice = RustSourceQ_choice_c239_e;
                self.value.c239 = decoder.read_bool();
            }
            239 => {
                self.choice = RustSourceQ_choice_c240_e;
                self.value.c240 = decoder.read_bool();
            }
            240 => {
                self.choice = RustSourceQ_choice_c241_e;
                self.value.c241 = decoder.read_bool();
            }
            241 => {
                self.choice = RustSourceQ_choice_c242_e;
                self.value.c242 = decoder.read_bool();
            }
            242 => {
                self.choice = RustSourceQ_choice_c243_e;
                self.value.c243 = decoder.read_bool();
            }
            243 => {
                self.choice = RustSourceQ_choice_c244_e;
                self.value.c244 = decoder.read_bool();
            }
            244 => {
                self.choice = RustSourceQ_choice_c245_e;
                self.value.c245 = decoder.read_bool();
            }
            245 => {
                self.choice = RustSourceQ_choice_c246_e;
                self.value.c246 = decoder.read_bool();
            }
            246 => {
                self.choice = RustSourceQ_choice_c247_e;
                self.value.c247 = decoder.read_bool();
            }
            247 => {
                self.choice = RustSourceQ_choice_c248_e;
                self.value.c248 = decoder.read_bool();
            }
            248 => {
                self.choice = RustSourceQ_choice_c249_e;
                self.value.c249 = decoder.read_bool();
            }
            249 => {
                self.choice = RustSourceQ_choice_c250_e;
                self.value.c250 = decoder.read_bool();
            }
            250 => {
                self.choice = RustSourceQ_choice_c251_e;
                self.value.c251 = decoder.read_bool();
            }
            251 => {
                self.choice = RustSourceQ_choice_c252_e;
                self.value.c252 = decoder.read_bool();
            }
            252 => {
                self.choice = RustSourceQ_choice_c253_e;
                self.value.c253 = decoder.read_bool();
            }
            253 => {
                self.choice = RustSourceQ_choice_c254_e;
                self.value.c254 = decoder.read_bool();
            }
            254 => {
                self.choice = RustSourceQ_choice_c255_e;
                self.value.c255 = decoder.read_bool();
            }
            255 => {
                self.choice = RustSourceQ_choice_c256_e;
                self.value.c256 = decoder.read_bool();
            }
            256 => {
                self.choice = RustSourceQ_choice_c257_e;
                self.value.c257 = decoder.read_bool();
            }
            _ => decoder.abort(EBADCHOICE);
        }
    }
}

/// Type AC in module RustSource.
#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceAC {
    pub a: struct a_rust_source_q_t,
    pub b: struct a_rust_source_d_t
}

impl RustSourceAC {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        self.a.encode_inner(&mut encoder);
        self.b.encode_inner(&mut encoder);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.a.decode_inner(&mut decoder);
        self.b.decode_inner(&mut decoder);
    }
}

/// Type B in module RustSource.
enum RustSourceB_choice_e choice;
union {
    i8 a;
    struct a_rust_source_a_t b;
} value;

impl RustSourceB {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        match self.choice {
            RustSourceB_choice_a_e => {
                encoder.append_non_negative_binary_integer(0, 2);
                encoder.append_i8(self.value.a);
            }
            RustSourceB_choice_b_e => {
                encoder.append_non_negative_binary_integer(1, 2);
                self.value.b.encode_inner(&mut encoder);
            }
            RustSourceB_choice_c_e => {
                encoder.append_non_negative_binary_integer(2, 2);
            }
            _ => encoder.abort(EBADCHOICE);
        }
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        choice = decoder.read_non_negative_binary_integer(2);

        match choice {
            0 => {
                self.choice = RustSourceB_choice_a_e;
                self.value.a = decoder.read_i8();
            }
            1 => {
                self.choice = RustSourceB_choice_b_e;
                self.value.b.decode_inner(&mut decoder);
            }
            2 => {
                self.choice = RustSourceB_choice_c_e;
            }
            _ => decoder.abort(EBADCHOICE);
        }
    }
}

/// Type C in module RustSource.
let length: u8;
struct a_rust_source_b_t elements[2];

impl RustSourceC {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.length - 0) as u64,
            2);

        for i in 0..self.length {
            self.elements[i].encode_inner(&mut encoder);
        }
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.length = decoder.read_non_negative_binary_integer(2);
        self.length += 0;

        if self.length > 2 {
            decoder.abort(EBADLENGTH);

            return;
        }

        for i in 0..self.length {
            self.elements[i].decode_inner(&mut decoder);
        }
    }
}

/// Type E in module RustSource.
struct {
    enum RustSourceEA_choice_e choice;
    union {
        struct {
            enum RustSourceEAB_choice_e choice;
            union {
                bool c;
            } value;
        } b;
    } value;
}

#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceE {
    pub a: RustSourceEA
}

impl RustSourceE {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        match self.a.choice {
            RustSourceEA_choice_b_e => {
                encoder.append_non_negative_binary_integer(0, 0);

                match self.a.value.b.choice {
                    RustSourceEAB_choice_c_e => {
                        encoder.append_non_negative_binary_integer(0, 0);
                        encoder.append_bool(self.a.value.b.value.c);
                    }
                    _ => encoder.abort(EBADCHOICE);
                }
            }
            _ => encoder.abort(EBADCHOICE);
        }
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        choice = decoder.read_non_negative_binary_integer(0);

        match choice {
            0 => {
                self.a.choice = RustSourceEA_choice_b_e;
                choice_2 = decoder.read_non_negative_binary_integer(0);

                match choice_2 {
                    0 => {
                        self.a.value.b.choice = RustSourceEAB_choice_c_e;
                        self.a.value.b.value.c = decoder.read_bool();
                    }
                    _ => decoder.abort(EBADCHOICE);
                }
            }
            _ => decoder.abort(EBADCHOICE);
        }
    }
}

/// Type F in module RustSource.
let length: u8;
struct {
    bool elements[1];
} elements[2];

impl RustSourceF {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.length - 1) as u64,
            1);

        for i in 0..self.length {
            for i_2 in 0..1 {
                encoder.append_bool(self.elements[i].elements[i_2]);
            }
        }
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.length = decoder.read_non_negative_binary_integer(1);
        self.length += 1;

        for i in 0..self.length {
            for i_2 in 0..1 {
                self.elements[i].elements[i_2] = decoder.read_bool();
            }
        }
    }
}

/// Type G in module RustSource.
#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceG {
    pub is_a_present: bool,
    pub a: bool,
    pub is_b_present: bool,
    pub b: bool,
    pub is_c_present: bool,
    pub c: bool,
    pub is_d_present: bool,
    pub d: bool,
    pub is_e_present: bool,
    pub e: bool,
    pub is_f_present: bool,
    pub f: bool,
    pub is_g_present: bool,
    pub g: bool,
    pub is_h_present: bool,
    pub h: bool,
    pub is_i_present: bool,
    pub i: bool
}

impl RustSourceG {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_bit(self.is_a_present as u8);
        encoder.append_bit(self.is_b_present as u8);
        encoder.append_bit(self.is_c_present as u8);
        encoder.append_bit(self.is_d_present as u8);
        encoder.append_bit(self.is_e_present as u8);
        encoder.append_bit(self.is_f_present as u8);
        encoder.append_bit(self.is_g_present as u8);
        encoder.append_bit(self.is_h_present as u8);
        encoder.append_bit(self.is_i_present as u8);

        if src.is_a_present {
            encoder.append_bool(self.a);
        }

        if src.is_b_present {
            encoder.append_bool(self.b);
        }

        if src.is_c_present {
            encoder.append_bool(self.c);
        }

        if src.is_d_present {
            encoder.append_bool(self.d);
        }

        if src.is_e_present {
            encoder.append_bool(self.e);
        }

        if src.is_f_present {
            encoder.append_bool(self.f);
        }

        if src.is_g_present {
            encoder.append_bool(self.g);
        }

        if src.is_h_present {
            encoder.append_bool(self.h);
        }

        if src.is_i_present {
            encoder.append_bool(self.i);
        }
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.is_a_present = decoder.read_bit() != 0;
        self.is_b_present = decoder.read_bit() != 0;
        self.is_c_present = decoder.read_bit() != 0;
        self.is_d_present = decoder.read_bit() != 0;
        self.is_e_present = decoder.read_bit() != 0;
        self.is_f_present = decoder.read_bit() != 0;
        self.is_g_present = decoder.read_bit() != 0;
        self.is_h_present = decoder.read_bit() != 0;
        self.is_i_present = decoder.read_bit() != 0;

        if dst.is_a_present {
            self.a = decoder.read_bool();
        }

        if dst.is_b_present {
            self.b = decoder.read_bool();
        }

        if dst.is_c_present {
            self.c = decoder.read_bool();
        }

        if dst.is_d_present {
            self.d = decoder.read_bool();
        }

        if dst.is_e_present {
            self.e = decoder.read_bool();
        }

        if dst.is_f_present {
            self.f = decoder.read_bool();
        }

        if dst.is_g_present {
            self.g = decoder.read_bool();
        }

        if dst.is_h_present {
            self.h = decoder.read_bool();
        }

        if dst.is_i_present {
            self.i = decoder.read_bool();
        }
    }
}

/// Type H in module RustSource.
dummy: u8;

impl RustSourceH {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        (void)src_p;
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        (void)dst_p;
    }
}

/// Type I in module RustSource.
struct RustSourceI {
pub buf: [u8; 24]

impl RustSourceI {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_bytes(&self.buf);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        decoder.read_bytes(&mut self.buf);
    }
}

/// Type J in module RustSource.
struct RustSourceJ {
let length: u8;
pub buf: [u8; 23]

impl RustSourceJ {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.length - 22) as u64,
            1);
        encoder.append_bytes(&self.buf,
                             self.length);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.length = decoder.read_non_negative_binary_integer(
            1);
        self.length += 22;
        decoder.read_bytes(&mut self.buf,
                           self.length);
    }
}

/// Type K in module RustSource.
#[derive(Debug, PartialEq, Copy, Clone)] value;
pub enum RustSourceK {
    A,
}

impl Default for RustSourceK {
    fn default() -> Self {
        RustSourceK::A
    }
}

impl RustSourceK {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(self.value, 0);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(0);
    }
}

/// Type L in module RustSource.
struct RustSourceL {
let length: u32;
pub buf: [u8; 500]

impl RustSourceL {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.length - 0) as u64,
            9);
        encoder.append_bytes(&self.buf,
                             self.length);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.length = decoder.read_non_negative_binary_integer(
            9);
        self.length += 0;

        if self.length > 500 {
            decoder.abort(EBADLENGTH);

            return;
        }

        decoder.read_bytes(&mut self.buf,
                           self.length);
    }
}

/// Type O in module RustSource.
let length: u32;
bool elements[260];

impl RustSourceO {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.length - 1) as u64,
            9);

        for i in 0..self.length {
            encoder.append_bool(self.elements[i]);
        }
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.length = decoder.read_non_negative_binary_integer(9);
        self.length += 1;

        if self.length > 260 {
            decoder.abort(EBADLENGTH);

            return;
        }

        for i in 0..self.length {
            self.elements[i] = decoder.read_bool();
        }
    }
}

/// Type N in module RustSource.
#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceN {
    pub a: struct a_rust_source_k_t,
    pub b: struct a_rust_source_a_t,
    pub c: struct a_rust_source_o_t
}

impl RustSourceN {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        self.a.encode_inner(&mut encoder);
        self.b.encode_inner(&mut encoder);
        self.c.encode_inner(&mut encoder);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.a.decode_inner(&mut decoder);
        self.b.decode_inner(&mut decoder);
        self.c.decode_inner(&mut decoder);
    }
}

/// Type M in module RustSource.
#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceM {
    pub a: struct a_rust_source_k_t,
    pub b: struct a_rust_source_n_t
}

impl RustSourceM {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        self.a.encode_inner(&mut encoder);
        self.b.encode_inner(&mut encoder);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.a.decode_inner(&mut decoder);
        self.b.decode_inner(&mut decoder);
    }
}

/// Type P in module RustSource.
#[derive(Debug, Default, PartialEq, Copy, Clone)]
pub struct RustSourceP {
    pub a: struct a_rust_source_a_t,
    pub b: struct a_rust_source_m_t,
    pub c: struct a_rust_source_f_t
}

impl RustSourceP {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        self.a.encode_inner(&mut encoder);
        self.b.encode_inner(&mut encoder);
        self.c.encode_inner(&mut encoder);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.a.decode_inner(&mut decoder);
        self.b.decode_inner(&mut decoder);
        self.c.decode_inner(&mut decoder);
    }
}

/// Type R in module RustSource.
i8 value;

impl RustSourceR {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.value - -1) as u64,
            1);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(1) as i8;
        self.value += -1;
    }
}

/// Type S in module RustSource.
i8 value;

impl RustSourceS {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.value - -2) as u64,
            2);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(2) as i8;
        self.value += -2;
    }
}

/// Type T in module RustSource.
i8 value;

impl RustSourceT {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.value - -1) as u64,
            2);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(2) as i8;
        self.value += -1;
    }
}

/// Type U in module RustSource.
i8 value;

impl RustSourceU {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.value - -64) as u64,
            7);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(7) as i8;
        self.value += -64;
    }
}

/// Type V in module RustSource.
i8 value;

impl RustSourceV {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_i8(self.value);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_i8();
    }
}

/// Type W in module RustSource.
i16 value;

impl RustSourceW {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.value - -1) as u64,
            9);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(9) as i16;
        self.value += -1;
    }
}

/// Type X in module RustSource.
i16 value;

impl RustSourceX {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.value - -2) as u64,
            10);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(10) as i16;
        self.value += -2;
    }
}

/// Type Y in module RustSource.
u16 value;

impl RustSourceY {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_non_negative_binary_integer(
            (self.value - 10000) as u64,
            10);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_non_negative_binary_integer(10) as u16;
        self.value += 10000;
    }
}

/// Type Z in module RustSource.
bool value;

impl RustSourceZ {
    pub fn encode(&mut self, mut dst: &mut [u8]) -> Result<usize, Error> {
        let mut encoder = Encoder::new(&mut dst);

        self.encode_inner(&mut encoder);

        encoder.get_result()
    }

    pub fn decode(&mut self, src: &[u8]) -> Result<usize, Error> {
        let mut decoder = Decoder::new(&src);

        self.decode_inner(&mut decoder);

        decoder.get_result()
    }

    fn encode_inner(&mut self, encoder: &mut Encoder) {
        encoder.append_bool(self.value);
    }

    fn decode_inner(&mut self, decoder: &mut Decoder) {
        self.value = decoder.read_bool();
    }
}
